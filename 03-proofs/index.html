
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../02-mltt/">
      
      
        <link rel="next" href="../04-overloading/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.44">
    
    
      
        <title>Construct Formal Proofs - Saki-Lang</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#construct-formal-proofs" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Saki-Lang" class="md-header__button md-logo" aria-label="Saki-Lang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 3h2v2H5v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5h2v2H5c-1.07-.27-2-.9-2-2v-4a2 2 0 0 0-2-2H0v-2h1a2 2 0 0 0 2-2V5a2 2 0 0 1 2-2m14 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-5a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3zm-7 12a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m-4 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m8 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Saki-Lang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Construct Formal Proofs
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Saki-Lang" class="md-nav__button md-logo" aria-label="Saki-Lang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 3h2v2H5v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5h2v2H5c-1.07-.27-2-.9-2-2v-4a2 2 0 0 0-2-2H0v-2h1a2 2 0 0 0 2-2V5a2 2 0 0 1 2-2m14 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-5a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3zm-7 12a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m-4 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m8 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1"/></svg>

    </a>
    Saki-Lang
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Introduction
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-keywords/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Keywords and Identifiers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-mltt/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Martin-Löf Type Theory
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Construct Formal Proofs
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Construct Formal Proofs
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#background" class="md-nav__link">
    <span class="md-ellipsis">
      Background
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Background">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#type-level-programming-and-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Type-Level Programming and Proofs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#curry-howard-correspondence" class="md-nav__link">
    <span class="md-ellipsis">
      Curry-Howard Correspondence
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dependent-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Dependent Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dependent-function-types-pi-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Function Types (\(\Pi\)-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependent-pair-types-sigma-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Pair Types (\(\Sigma\)-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universal-quantification-forall-and-dependent-pi-types" class="md-nav__link">
    <span class="md-ellipsis">
      Universal Quantification (\(\forall\)) and Dependent \(\Pi\)-Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#existential-quantification-exists-and-dependent-sigma-types" class="md-nav__link">
    <span class="md-ellipsis">
      Existential Quantification (\(\exists\)) and Dependent \(\Sigma\)-Types
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definition-of-equality-reflexivity-and-symmetry" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Equality, Reflexivity, and Symmetry
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Definition of Equality, Reflexivity, and Symmetry">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definition-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reflexivity-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Reflexivity of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#symmetry-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Symmetry of Equality
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Natural Numbers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Natural Numbers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inductive-definition-of-mathbbn-natural-numbers-peano-axioms" class="md-nav__link">
    <span class="md-ellipsis">
      Inductive Definition of \(\mathbb{N}\) (Natural Numbers): Peano Axioms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#definition-of-addition-for-natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Addition for Natural Numbers
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#induction-principles-and-theorems-on-natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Principles and Theorems on Natural Numbers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Induction Principles and Theorems on Natural Numbers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#induction-principle" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Principle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#induction-reduction" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Reduction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-n-0-n" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: \(n + 0 = n\)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leibniz-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Leibniz Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-n-n-0" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: \(n = n + 0\)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-successor-and-addition" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: Successor and Addition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transitivity-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Transitivity of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-commutativity-of-addition" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: Commutativity of Addition
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#complete-code" class="md-nav__link">
    <span class="md-ellipsis">
      Complete Code
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-overloading/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ad-Hoc Polymorphism (Overloading)
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-subtyping/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Subtyping and Algebraic Subtyping
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Definition
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Definition
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Definition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Definition
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Definition/01-decorator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Decorator
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Terms
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Terms
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Terms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/01-lambda/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Function (Lambda)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/02-dependent-pi/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dependent Pi (Function) Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/04-expr/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Expressions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/05-sum/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sum Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/06-pair/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Product Type (Pair) and Dependent Sigma Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/07-record/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Record
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/08-adt/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Algebraic Datatype
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/09-inductive/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Inductive Type with Indices
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/10-constraint/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Constraint Universe
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#background" class="md-nav__link">
    <span class="md-ellipsis">
      Background
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Background">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#type-level-programming-and-proofs" class="md-nav__link">
    <span class="md-ellipsis">
      Type-Level Programming and Proofs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#curry-howard-correspondence" class="md-nav__link">
    <span class="md-ellipsis">
      Curry-Howard Correspondence
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dependent-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Dependent Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dependent-function-types-pi-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Function Types (\(\Pi\)-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependent-pair-types-sigma-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Pair Types (\(\Sigma\)-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universal-quantification-forall-and-dependent-pi-types" class="md-nav__link">
    <span class="md-ellipsis">
      Universal Quantification (\(\forall\)) and Dependent \(\Pi\)-Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#existential-quantification-exists-and-dependent-sigma-types" class="md-nav__link">
    <span class="md-ellipsis">
      Existential Quantification (\(\exists\)) and Dependent \(\Sigma\)-Types
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definition-of-equality-reflexivity-and-symmetry" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Equality, Reflexivity, and Symmetry
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Definition of Equality, Reflexivity, and Symmetry">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definition-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reflexivity-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Reflexivity of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#symmetry-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Symmetry of Equality
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Natural Numbers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Natural Numbers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inductive-definition-of-mathbbn-natural-numbers-peano-axioms" class="md-nav__link">
    <span class="md-ellipsis">
      Inductive Definition of \(\mathbb{N}\) (Natural Numbers): Peano Axioms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#definition-of-addition-for-natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Definition of Addition for Natural Numbers
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#induction-principles-and-theorems-on-natural-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Principles and Theorems on Natural Numbers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Induction Principles and Theorems on Natural Numbers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#induction-principle" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Principle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#induction-reduction" class="md-nav__link">
    <span class="md-ellipsis">
      Induction Reduction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-n-0-n" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: \(n + 0 = n\)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leibniz-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Leibniz Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-n-n-0" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: \(n = n + 0\)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-successor-and-addition" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: Successor and Addition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transitivity-of-equality" class="md-nav__link">
    <span class="md-ellipsis">
      Transitivity of Equality
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#theorem-commutativity-of-addition" class="md-nav__link">
    <span class="md-ellipsis">
      Theorem: Commutativity of Addition
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#complete-code" class="md-nav__link">
    <span class="md-ellipsis">
      Complete Code
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="construct-formal-proofs">Construct Formal Proofs</h1>
<script type="module" src="/javascripts/editor.js"></script>
<p><link rel="stylesheet" href="/static/styles.css"></p>
<h2 id="background">Background</h2>
<p>In modern software and systems development, especially in critical applications like artificial intelligence, cryptography, and distributed systems, ensuring code correctness is of utmost importance. Errors in these domains can lead to severe consequences, ranging from security vulnerabilities to catastrophic failures in autonomous systems. Therefore, it's essential to rigorously verify code correctness. Formal proofs provide a solid foundation for this verification, ensuring that programs not only execute correctly but are mathematically guaranteed to meet their specifications.</p>
<p>A <strong>formal proof</strong> is a mathematically rigorous argument demonstrating the truth of a statement within a formal system. Unlike informal proofs that rely on intuition and natural language, formal proofs are expressed symbolically and precisely. They are designed to be machine-verifiable, meaning automated theorem provers or proof assistants can check them. This capability is particularly important in fields such as:</p>
<ul>
<li><strong>Software Verification</strong>: Ensuring that critical software components (e.g., in aerospace, medical devices, or autonomous systems) are free of bugs and perform as intended.</li>
<li><strong>AI Code Synthesis</strong>: Verified AI code synthesis uses formal proofs to ensure that automatically generated code meets its specification, reducing the risk of errors in complex systems generated by machine learning models.</li>
</ul>
<h3 id="type-level-programming-and-proofs">Type-Level Programming and Proofs</h3>
<p>In type-level programming, types are not just used for ensuring low-level correctness (e.g., checking that an integer is passed to a function expecting an integer) but for encoding complex logical propositions and ensuring that programs satisfy deep properties, such as invariants or theorems. When we speak of <strong>dependent types</strong>, these are types that depend on values, allowing us to encode even more detailed and precise properties about programs.</p>
<p>For example, when dealing with natural numbers, the proof of properties such as equality, commutativity, and associativity can be encoded directly in the type system. The formal proof of a mathematical statement like "equality is symmetric" becomes a recursive function over the natural numbers, and the type system ensures that the proof is complete and correct.</p>
<p>We will now move from this background into the concrete construction of a formal proof of the symmetry of equality for natural numbers. This construction will follow the principles of the Curry-Howard correspondence, where the proof is represented as a program in a type-safe, recursive language, and the proposition of symmetric equality is encoded as a type.</p>
<h2 id="curry-howard-correspondence">Curry-Howard Correspondence</h2>
<p>The <strong>Curry-Howard correspondence</strong>, also known as the propositions-as-types paradigm, is a foundational concept in type theory that establishes a deep relationship between logic and computation. According to this correspondence, logical propositions correspond to types in programming, and proofs of those propositions correspond to programs (or functions) that inhabit those types.</p>
<p>In this framework:</p>
<ul>
<li><strong>Logical Propositions</strong> (such as <span class="arithmatex">\(P \to Q\)</span>, <span class="arithmatex">\(P \land Q\)</span>, and <span class="arithmatex">\(P \lor Q\)</span>) correspond to <strong>types</strong> in programming languages.</li>
<li><strong>Proofs</strong> of these propositions correspond to <strong>programs</strong> (i.e., functions) that construct elements of these types.</li>
<li><strong>Constructive Proofs</strong>: A proof of a logical statement in this system is constructive, meaning that it not only asserts the truth of the proposition but also provides a method (i.e., an algorithm) for constructing evidence that the proposition holds.</li>
</ul>
<p>The Curry-Howard correspondence can be summarized as:</p>
<table>
<thead>
<tr>
<th>Logical Concept</th>
<th>Programming Concept</th>
</tr>
</thead>
<tbody>
<tr>
<td>Proposition <span class="arithmatex">\(P\)</span></td>
<td>Type <span class="arithmatex">\(T\)</span></td>
</tr>
<tr>
<td>Proof of <span class="arithmatex">\(P\)</span></td>
<td>Value of type <span class="arithmatex">\(T\)</span></td>
</tr>
<tr>
<td>Implication <span class="arithmatex">\(P \to Q\)</span></td>
<td>Function type <span class="arithmatex">\(T_1 \to T_2\)</span></td>
</tr>
<tr>
<td>Conjunction <span class="arithmatex">\(P \land Q\)</span></td>
<td>Pair type <span class="arithmatex">\(T_1 \times T_2\)</span></td>
</tr>
<tr>
<td>Disjunction <span class="arithmatex">\(P \lor Q\)</span></td>
<td>Sum type <span class="arithmatex">\(T_1 + T_2\)</span></td>
</tr>
<tr>
<td>Falsehood <span class="arithmatex">\(\bot\)</span></td>
<td>Empty type (no inhabitants)</td>
</tr>
<tr>
<td>Truth <span class="arithmatex">\(\top\)</span></td>
<td>Unit type (single inhabitant)</td>
</tr>
<tr>
<td>Universal quantification <span class="arithmatex">\(\forall\)</span></td>
<td>Dependent function type (<span class="arithmatex">\(\Pi\)</span>-type)</td>
</tr>
<tr>
<td>Existential quantification <span class="arithmatex">\(\exists\)</span></td>
<td>Dependent pair type (<span class="arithmatex">\(\Sigma\)</span>-type)</td>
</tr>
</tbody>
</table>
<p>Through the Curry-Howard correspondence, we can view formal proofs as programs, and the act of proving a theorem becomes synonymous with writing a program that satisfies the corresponding type signature. This correspondence has significant implications for formal verification, enabling the use of proof assistants (such as Coq, Agda, and Lean) to both prove mathematical theorems and verify the correctness of programs in type-safe programming languages like Saki, Haskell, or other dependent type systems.</p>
<p>For example, the proposition <span class="arithmatex">\(P \to Q\)</span> (i.e., if <span class="arithmatex">\(P\)</span> holds, then <span class="arithmatex">\(Q\)</span> holds) corresponds to a function that takes a value of type <span class="arithmatex">\(P\)</span> and returns a value of type <span class="arithmatex">\(Q\)</span>. Proving this proposition requires constructing such a function. Similarly, proving equality between two elements <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> corresponds to constructing a proof of type <span class="arithmatex">\(A.\text{Eq}(a, b)\)</span>, which can be interpreted as constructing a witness to the fact that <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are equal in the system.</p>
<h2 id="dependent-types">Dependent Types</h2>
<p><strong>Dependent types</strong> are an extension of the basic types used in functional programming languages. They allow types to depend on values, thus enabling richer and more precise specifications of programs. Two important forms of dependent types that correspond to universal and existential quantifiers in logic are:</p>
<h3 id="dependent-function-types-pi-types">Dependent Function Types (<span class="arithmatex">\(\Pi\)</span>-Types)</h3>
<p>These types correspond to the universal quantifier <span class="arithmatex">\(\forall\)</span> in logic. They are also called <strong>dependent function types</strong> because they generalize the function types to allow the output type to depend on the value of the input. Formally:</p>
<div class="arithmatex">\[
\Pi(x : A) . P(x)
\]</div>
<p>This represents a function that, for each value <span class="arithmatex">\(x\)</span> of type <span class="arithmatex">\(A\)</span>, returns a value of type <span class="arithmatex">\(P(x)\)</span>, where <span class="arithmatex">\(P(x)\)</span> is a type that may depend on <span class="arithmatex">\(x\)</span>. In logical terms, this corresponds to the statement "<span class="arithmatex">\(\forall x \in A, P(x)\)</span>" which means "for every <span class="arithmatex">\(x\)</span> of type <span class="arithmatex">\(A\)</span>, the proposition <span class="arithmatex">\(P(x)\)</span> holds."</p>
<p>In programming terms, this is a <strong>generalization of function types</strong> because the type of the result of the function can vary depending on the input. For example, in a dependently typed language, we might express the type of a list's length as a function from lists to natural numbers:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>length : ∀(A : Type) -&gt; List(A) -&gt; ℕ
</span></code></pre></div>
</div>

<p>This says that for every type <span class="arithmatex">\(A\)</span>, <code>length</code> is a function from a list of type <span class="arithmatex">\(A\)</span> to a natural number, describing the length of the list.</p>
<h3 id="dependent-pair-types-sigma-types">Dependent Pair Types (<span class="arithmatex">\(\Sigma\)</span>-Types)</h3>
<p>These types correspond to the existential quantifier <span class="arithmatex">\(\exists\)</span> in logic. They represent pairs where the type of the second element depends on the value of the first element. Formally:</p>
<div class="arithmatex">\[
\Sigma(x : A) . P(x)
\]</div>
<p>This represents a pair <span class="arithmatex">\((x, y)\)</span> where <span class="arithmatex">\(x\)</span> is of type <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(y\)</span> is of type <span class="arithmatex">\(P(x)\)</span>, where <span class="arithmatex">\(P(x)\)</span> depends on <span class="arithmatex">\(x\)</span>. In logical terms, this corresponds to the statement "<span class="arithmatex">\(\exists x \in A, P(x)\)</span>" which means "there exists an <span class="arithmatex">\(x\)</span> of type <span class="arithmatex">\(A\)</span> such that the proposition <span class="arithmatex">\(P(x)\)</span> holds."</p>
<p>In programming, a <span class="arithmatex">\(\Sigma\)</span>-type allows for encoding richer structures where some values depend on others. For example, we can encode the type of non-empty lists by using a <span class="arithmatex">\(\Sigma\)</span>-type where the list's first element exists and subsequent elements are of type <span class="arithmatex">\(A\)</span>:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>NonEmptyList(A : Type) = ∃(n : ℕ) × Vector(A, n)
</span></code></pre></div>
</div>

<p>This says that a non-empty list of type <span class="arithmatex">\(A\)</span> is a pair consisting of a natural number <span class="arithmatex">\(n\)</span> and a vector of <span class="arithmatex">\(n\)</span> elements of type <span class="arithmatex">\(A\)</span>. The second component depends on the first, reflecting the idea that the length of the list is tied to the vector's length.</p>
<h3 id="universal-quantification-forall-and-dependent-pi-types">Universal Quantification (<span class="arithmatex">\(\forall\)</span>) and Dependent <span class="arithmatex">\(\Pi\)</span>-Types</h3>
<p>In logic, the universal quantifier <span class="arithmatex">\(\forall\)</span> represents statements that hold for all elements of a certain set. In the Curry-Howard correspondence, <span class="arithmatex">\(\forall\)</span> corresponds to the <strong>dependent function type</strong> (also called the <strong><span class="arithmatex">\(\Pi\)</span>-type</strong>). A proposition <span class="arithmatex">\(\forall x \in A, P(x)\)</span> is equivalent to constructing a function that, given any <span class="arithmatex">\(x\)</span> of type <span class="arithmatex">\(A\)</span>, returns a proof of <span class="arithmatex">\(P(x)\)</span>. </p>
<p>For example, to prove a statement like "<span class="arithmatex">\(\forall n \in \mathbb{N}, n + 0 = n\)</span>" (i.e., zero is the identity element for addition over natural numbers), we construct a function that takes a natural number <span class="arithmatex">\(n\)</span> and returns a proof that <span class="arithmatex">\(n + 0 = n\)</span>.</p>
<p>In type theory, the dependent function type <span class="arithmatex">\(\Pi(x : A) . P(x)\)</span> is used to encode this idea. It represents a function that, for each <span class="arithmatex">\(x \in A\)</span>, returns a value of type <span class="arithmatex">\(P(x)\)</span>, where <span class="arithmatex">\(P(x)\)</span> can depend on the input <span class="arithmatex">\(x\)</span>. </p>
<h3 id="existential-quantification-exists-and-dependent-sigma-types">Existential Quantification (<span class="arithmatex">\(\exists\)</span>) and Dependent <span class="arithmatex">\(\Sigma\)</span>-Types</h3>
<p>The existential quantifier <span class="arithmatex">\(\exists\)</span> in logic asserts the existence of an element with a certain property. In the Curry-Howard correspondence, <span class="arithmatex">\(\exists\)</span> corresponds to the <strong>dependent pair type</strong> (or <strong><span class="arithmatex">\(\Sigma\)</span>-type</strong>). A proposition <span class="arithmatex">\(\exists x \in A, P(x)\)</span> is equivalent to constructing a pair consisting of an element <span class="arithmatex">\(x\)</span> of type <span class="arithmatex">\(A\)</span> and a proof that <span class="arithmatex">\(P(x)\)</span> holds for that <span class="arithmatex">\(x\)</span>.</p>
<p>In type theory, the dependent pair type <span class="arithmatex">\(\Sigma(x : A) . P(x)\)</span> is used to encode this idea. It represents a pair <span class="arithmatex">\((x, p)\)</span>, where <span class="arithmatex">\(x\)</span> is an element of type <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(p\)</span> is a proof that <span class="arithmatex">\(P(x)\)</span> holds. The type <span class="arithmatex">\(P(x)\)</span> can depend on <span class="arithmatex">\(x\)</span>, allowing us to express properties that vary depending on the value of <span class="arithmatex">\(x\)</span>.</p>
<p>For instance, if we want to express the statement "there exists a natural number <span class="arithmatex">\(n\)</span> such that <span class="arithmatex">\(n\)</span> is even," we could use a <span class="arithmatex">\(\Sigma\)</span>-type to represent this in type theory:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>EvenNumber = ∃(n : ℕ) × isEven(n)
</span></code></pre></div>
</div>

<p>This type encodes both the natural number <span class="arithmatex">\(n\)</span> and a proof that <span class="arithmatex">\(n\)</span> satisfies the property of being even.</p>
<h2 id="definition-of-equality-reflexivity-and-symmetry">Definition of Equality, Reflexivity, and Symmetry</h2>
<p>We begin by establishing the formal definitions of equality, reflexivity, and symmetry within the framework of type theory. These definitions are critical for the subsequent construction of inductive proofs on natural numbers.</p>
<h3 id="definition-of-equality">Definition of Equality</h3>
<p>The equality relation between two elements <span class="arithmatex">\(a, b\)</span> of a type <span class="arithmatex">\(A\)</span> is defined as a dependent type <span class="arithmatex">\(A.Eq(a, b)\)</span>, which asserts that <span class="arithmatex">\(a\)</span> and <span class="arithmatex">\(b\)</span> are equal. This is expressed using a dependent type <span class="arithmatex">\(A \to \mathcal{U}\)</span> where <span class="arithmatex">\(\mathcal{U}\)</span> is the universe of types. Formally, the equality type <span class="arithmatex">\(A.Eq(a, b)\)</span> is defined as:</p>
<div class="arithmatex">\[
Eq_A(a, b) :\equiv \forall (P : A \to \mathcal{U}) . P(a) \to P(b)
\]</div>
<p>This means that <span class="arithmatex">\(A.Eq(a, b)\)</span> holds if, for all propositions <span class="arithmatex">\(P\)</span> on <span class="arithmatex">\(A\)</span>, whenever <span class="arithmatex">\(P(a)\)</span> is true, <span class="arithmatex">\(P(b)\)</span> must also hold. In essence, this defines equality as the ability to substitute <span class="arithmatex">\(a\)</span> for <span class="arithmatex">\(b\)</span> in any context described by <span class="arithmatex">\(P\)</span>.</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>def Eq(A: &#39;Type, a b: A): &#39;Type = ∀(P: A -&gt; &#39;Type) -&gt; P(a) -&gt; P(b)
</span></code></pre></div>
</div>

<h3 id="reflexivity-of-equality">Reflexivity of Equality</h3>
<p>The property of <strong>reflexivity</strong> asserts that any element <span class="arithmatex">\(a\)</span> of a type <span class="arithmatex">\(A\)</span> is equal to itself. This is a fundamental axiom of equality, which can be proven for all types by constructing a proof using the definition of equality.</p>
<p>For any element <span class="arithmatex">\(a \in A\)</span>, reflexivity is stated as:</p>
<div class="arithmatex">\[
\text{refl}_A : \forall(a: A) . Eq_A(a, a) :\equiv \lambda (P : A \to \mathcal{U}) . \lambda (p : P(a)) . p
\]</div>
<p>This is trivially true because the proof <span class="arithmatex">\(pa : P(a)\)</span> already holds. Reflexivity is defined as:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>def refl(A: &#39;Type, a: A): A.Eq(a, a) = (P: A -&gt; &#39;Type, p: P(a)) =&gt; p
</span></code></pre></div>
</div>

<p>This expresses that for any proposition <span class="arithmatex">\(P\)</span>, if <span class="arithmatex">\(P(a)\)</span> holds, then <span class="arithmatex">\(P(a)\)</span> trivially holds again, establishing that <span class="arithmatex">\(a = a\)</span>.</p>
<h3 id="symmetry-of-equality">Symmetry of Equality</h3>
<p>The property of <strong>symmetry</strong> states that if <span class="arithmatex">\(a = b\)</span>, then <span class="arithmatex">\(b = a\)</span>. Formally, given a proof <span class="arithmatex">\(A.Eq(a, b)\)</span>, we construct a proof of <span class="arithmatex">\(A.Eq(b, a)\)</span>.</p>
<p>The symmetry of equality is defined as follows:</p>
<div class="arithmatex">\[
\begin{align}
\text{symm}_A : &amp; \, \forall(a, b: A) . Eq_A(a, b) \to Eq_A(b, a) 
    \\ &amp; :\equiv \lambda (e_{ab} : Eq_A(a, b)) . e_{ab}(\lambda (b' : A) . Eq_A(b', a), \text{refl}_A(a))
\end{align}
\]</div>
<p>Given a proof of <span class="arithmatex">\(A.Eq(a, b)\)</span>, we construct a proof of <span class="arithmatex">\(A.Eq(b, a)\)</span> by applying <span class="arithmatex">\(A.Eq(a, b)\)</span> to the proposition <span class="arithmatex">\(P(b') = A.Eq(b', a)\)</span>, and using the reflexivity of <span class="arithmatex">\(a\)</span>. This is formally stated as:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>def symmetry(A: &#39;Type, a b: A, eqab: A.Eq(a, b)): A.Eq(b, a) = {
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>    eqab((b&#39;: A) =&gt; A.Eq(b&#39;, a), A.refl(a))
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>}
</span></code></pre></div>
</div>

<p>This construction uses the existing proof <span class="arithmatex">\(eqab : A.Eq(a, b)\)</span> to establish <span class="arithmatex">\(A.Eq(b, a)\)</span>, thereby proving symmetry.</p>
<h2 id="natural-numbers">Natural Numbers</h2>
<p>We now turn to the formal inductive definition of the natural numbers <span class="arithmatex">\(\mathbb{N}\)</span>, which forms the basis for all subsequent proofs.</p>
<h3 id="inductive-definition-of-mathbbn-natural-numbers-peano-axioms">Inductive Definition of <span class="arithmatex">\(\mathbb{N}\)</span> (Natural Numbers): Peano Axioms</h3>
<p>The <strong>Peano axioms</strong> provide a formal foundation for the natural numbers and their properties. These axioms define the structure of <span class="arithmatex">\(\mathbb{N}\)</span> (the set of natural numbers) in a recursive manner. The Peano axioms, originally formulated by Giuseppe Peano in 1889, consist of a set of rules that describe how natural numbers are constructed and how operations like addition and equality are defined.</p>
<p>The Peano axioms can be summarized as follows:</p>
<ol>
<li>
<p><strong>Zero is a natural number</strong>: <span class="arithmatex">\(Z \in \mathbb{N}\)</span>.</p>
</li>
<li>
<p><strong>Every natural number has a successor</strong>: For each <span class="arithmatex">\(n \in \mathbb{N}\)</span>, there exists a successor <span class="arithmatex">\(S(n) \in \mathbb{N}\)</span>, which represents the next natural number after <span class="arithmatex">\(n\)</span>.</p>
</li>
<li>
<p><strong>Zero is not the successor of any number</strong>: <span class="arithmatex">\(\forall n \in \mathbb{N}, S(n) \neq Z\)</span>.</p>
</li>
<li>
<p><strong>Distinct numbers have distinct successors</strong>: <span class="arithmatex">\(\forall n, m \in \mathbb{N}, S(n) = S(m) \implies n = m\)</span>.</p>
</li>
<li>
<p><strong>Mathematical induction</strong>: If a property <span class="arithmatex">\(P\)</span> holds for zero and holds for the successor of <span class="arithmatex">\(n\)</span> whenever it holds for <span class="arithmatex">\(n\)</span>, then <span class="arithmatex">\(P\)</span> holds for all natural numbers <span class="arithmatex">\(n\)</span>.</p>
</li>
</ol>
<p>These axioms define the structure of the natural numbers and allow us to reason about properties such as addition, multiplication, and equality in a recursive manner. The natural numbers, as defined by these axioms, are typically represented as:</p>
<div class="arithmatex">\[
\mathbb{N} ::= Z \mid S(n) \quad \text{where } n \in \mathbb{N}
\]</div>
<ul>
<li><span class="arithmatex">\(Z\)</span> is the natural number zero.</li>
<li><span class="arithmatex">\(S(n)\)</span> is the successor of <span class="arithmatex">\(n\)</span>, representing the number immediately following <span class="arithmatex">\(n\)</span>.</li>
</ul>
<p>For example:</p>
<ul>
<li><span class="arithmatex">\(Z\)</span> represents the number <span class="arithmatex">\(0\)</span>,</li>
<li><span class="arithmatex">\(S(Z)\)</span> represents <span class="arithmatex">\(1\)</span>,</li>
<li><span class="arithmatex">\(S(S(Z))\)</span> represents <span class="arithmatex">\(2\)</span>, and so on.</li>
</ul>
<p>The natural numbers are defined inductively by two constructors:</p>
<ul>
<li><span class="arithmatex">\(\text{Zero} : \mathbb{N}\)</span>, representing the number <span class="arithmatex">\(0\)</span>,</li>
<li><span class="arithmatex">\(\text{Succ} : \mathbb{N} \to \mathbb{N}\)</span>, representing the successor of a natural number <span class="arithmatex">\(n\)</span>.</li>
</ul>
<p>Formally, the inductive type <span class="arithmatex">\(\mathbb{N}\)</span> is given by:</p>
<div class="arithmatex">\[
\mathbb{N} ::= \text{Zero} \mid \text{Succ}(n) \quad \text{where } n \in \mathbb{N}
\]</div>
<p>This is captured in the following Saki code:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>type ℕ = inductive {
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>    Zero
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>    Succ(ℕ)
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>}
</span></code></pre></div>
</div>

<p>To make the proof code clear, we add some extra definitions for further proof: </p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>operator binary (===) left-assoc {
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>    looser-than (+)
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>}
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>def (===)(a b: ℕ): &#39;Type = ℕ.Eq(a, b)
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a>def o: ℕ = ℕ::Zero
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>def succ(n: ℕ): ℕ = ℕ::Succ(n)
</span></code></pre></div>
</div>

<h3 id="definition-of-addition-for-natural-numbers">Definition of Addition for Natural Numbers</h3>
<p>Addition on natural numbers is defined recursively. For <span class="arithmatex">\(a, b \in \mathbb{N}\)</span>, the addition function <span class="arithmatex">\(+\)</span> is defined as:
$$
+ : \mathbb{N} \to \mathbb{N} \to \mathbb{N}
$$
$$
a + 0 = a
$$
$$
a + \text{Succ}(b) = \text{Succ}(a + b)
$$</p>
<p>and is formally defined in Saki code below:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>def (+)(a b : ℕ): ℕ = match a {
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a>    case ℕ::Zero =&gt; b
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a>    case ℕ::Succ(a&#39;) =&gt; ℕ::Succ(a&#39; + b)
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a>}
</span></code></pre></div>
</div>

<ul>
<li><strong>Base Case</strong>: When <span class="arithmatex">\(a = 0\)</span>, <span class="arithmatex">\(a + b = b\)</span>.</li>
<li><strong>Recursive Step</strong>: When <span class="arithmatex">\(a = \text{Succ}(a')\)</span>, <span class="arithmatex">\(a + b = \text{Succ}(a' + b)\)</span>, adding one to the result of adding <span class="arithmatex">\(a'\)</span> and <span class="arithmatex">\(b\)</span>.</li>
</ul>
<h2 id="induction-principles-and-theorems-on-natural-numbers">Induction Principles and Theorems on Natural Numbers</h2>
<p>Let <span class="arithmatex">\(\mathbb{N}\)</span> be the type of natural numbers, defined inductively by <span class="arithmatex">\(\text{Zero} : \mathbb{N}\)</span> and <span class="arithmatex">\(\text{Succ} : \mathbb{N} \to \mathbb{N}\)</span>. The following formal proof is conducted using type theory and the induction principle, denoted as follows:</p>
<h3 id="induction-principle">Induction Principle</h3>
<p>Let <span class="arithmatex">\(P : \mathbb{N} \to \mathcal{U}\)</span> be a dependent type, where <span class="arithmatex">\(\mathcal{U}\)</span> is the universe of types. The induction principle on natural numbers is formulated as:</p>
<div class="arithmatex">\[
\text{induction}_{\mathbb{N}} : \prod_{P : \mathbb{N} \to \mathcal{U}} P(\text{Zero}) \to \left( \prod_{n : \mathbb{N}} P(n) \to P(\text{Succ}(n)) \right) \to \prod_{n : \mathbb{N}} P(n)
\]</div>
<p>This principle constructs a proof that <span class="arithmatex">\(P(n)\)</span> holds for all <span class="arithmatex">\(n \in \mathbb{N}\)</span>, given that <span class="arithmatex">\(P(\text{Zero})\)</span> holds and that <span class="arithmatex">\(P(n) \to P(\text{Succ}(n))\)</span> holds for all <span class="arithmatex">\(n \in \mathbb{N}\)</span>.</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>def induction(
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>    P: ℕ -&gt; &#39;Type,
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>    base: P(ℕ::Zero),
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>    induce: ∀(n: ℕ) -&gt; P(n) -&gt; P(n.succ),
</span><span id="__span-9-5"><a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a>    nat: ℕ,
</span><span id="__span-9-6"><a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a>): P(nat) = match nat {
</span><span id="__span-9-7"><a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a>    case ℕ::Zero =&gt; base
</span><span id="__span-9-8"><a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a>    case ℕ::Succ(n&#39;) =&gt; induce(n&#39;, P.induction(base, induce, n&#39;))
</span><span id="__span-9-9"><a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a>}
</span></code></pre></div>
</div>

<h3 id="induction-reduction">Induction Reduction</h3>
<p>Let <span class="arithmatex">\(a, b : \mathbb{N}\)</span> and <span class="arithmatex">\(P : \mathbb{N} \to \mathcal{U}\)</span> be a dependent type. To simplify inductive proofs, we define a reduction function based on symmetry:</p>
<div class="arithmatex">\[
\text{inductionReduce} : \prod_{a, b : \mathbb{N}} (b = a) \to P(a) \to P(b)
\]</div>
<p>This function allows us to reverse the direction of an equality <span class="arithmatex">\(b = a\)</span> to <span class="arithmatex">\(a = b\)</span> via the symmetry of equality and use <span class="arithmatex">\(P(a)\)</span> to derive <span class="arithmatex">\(P(b)\)</span>.</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>def inductionReduce(
</span><span id="__span-10-2"><a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a>    a b: ℕ,
</span><span id="__span-10-3"><a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a>    eqba: (b === a),
</span><span id="__span-10-4"><a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a>    P: ℕ -&gt; &#39;Type,
</span><span id="__span-10-5"><a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a>    pa: P(a),
</span><span id="__span-10-6"><a id="__codelineno-10-6" name="__codelineno-10-6" href="#__codelineno-10-6"></a>): P(b) = {
</span><span id="__span-10-7"><a id="__codelineno-10-7" name="__codelineno-10-7" href="#__codelineno-10-7"></a>    let eqab = ℕ.symmetry(b, a, eqba)
</span><span id="__span-10-8"><a id="__codelineno-10-8" name="__codelineno-10-8" href="#__codelineno-10-8"></a>    eqab(P, pa)
</span><span id="__span-10-9"><a id="__codelineno-10-9" name="__codelineno-10-9" href="#__codelineno-10-9"></a>}
</span></code></pre></div>
</div>

<h3 id="theorem-n-0-n">Theorem: <span class="arithmatex">\(n + 0 = n\)</span></h3>
<p>We prove by induction on <span class="arithmatex">\(n \in \mathbb{N}\)</span> that <span class="arithmatex">\(n + 0 = n\)</span>:
$$
\forall n \in \mathbb{N}, n + 0 = n
$$</p>
<p>This is formalized using the induction principle:</p>
<div class="arithmatex">\[
\text{theoremPlusZero} : \prod_{n : \mathbb{N}} (n + 0 = n)
\]</div>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>def theoremPlusZero: ∀(n: ℕ) -&gt; (n + o === n) = {
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a>    ((n: ℕ) =&gt; (n + o === n)).induction(
</span><span id="__span-11-3"><a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a>        ℕ.refl(ℕ::Zero),
</span><span id="__span-11-4"><a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a>        (n: ℕ, assumption: (n + o === n)) =&gt; {
</span><span id="__span-11-5"><a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a>            inductionReduce(
</span><span id="__span-11-6"><a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a>                n, n + o, assumption,
</span><span id="__span-11-7"><a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a>                (n&#39;: ℕ) =&gt; (n&#39;.succ === n.succ),
</span><span id="__span-11-8"><a id="__codelineno-11-8" name="__codelineno-11-8" href="#__codelineno-11-8"></a>                ℕ.refl(n.succ)
</span><span id="__span-11-9"><a id="__codelineno-11-9" name="__codelineno-11-9" href="#__codelineno-11-9"></a>            )
</span><span id="__span-11-10"><a id="__codelineno-11-10" name="__codelineno-11-10" href="#__codelineno-11-10"></a>        }
</span><span id="__span-11-11"><a id="__codelineno-11-11" name="__codelineno-11-11" href="#__codelineno-11-11"></a>    )
</span><span id="__span-11-12"><a id="__codelineno-11-12" name="__codelineno-11-12" href="#__codelineno-11-12"></a>}
</span></code></pre></div>
</div>

<p>This inductive proof proceeds as follows:</p>
<ul>
<li><strong>Base Case</strong>: <span class="arithmatex">\(0 + 0 = 0\)</span>, by reflexivity of equality.</li>
<li><strong>Inductive Step</strong>: Assume <span class="arithmatex">\(n + 0 = n\)</span>, and prove that <span class="arithmatex">\(S(n) + 0 = S(n)\)</span>, which follows from the inductive hypothesis and the definition of addition.</li>
</ul>
<h3 id="leibniz-equality">Leibniz Equality</h3>
<p>We define the Leibniz rule of equality, which states that if <span class="arithmatex">\(a = b\)</span>, then for any function <span class="arithmatex">\(f : \mathbb{N} \to \mathbb{N}\)</span>, <span class="arithmatex">\(f(a) = f(b)\)</span>. This is formalized as:</p>
<div class="arithmatex">\[
\text{leibnizEq} : \prod_{a, b : \mathbb{N}} (a = b) \to \prod_{f : \mathbb{N} \to \mathbb{N}} f(a) = f(b)
\]</div>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>def leibnizEq(f: ℕ -&gt; ℕ): ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (a === b) -&gt; (f(a) === f(b)) = {
</span><span id="__span-12-2"><a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a>    (a b : ℕ, eqab: (a === b)) =&gt; {
</span><span id="__span-12-3"><a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a>        (P: ℕ -&gt; &#39;Type, pfa: P(f a)) =&gt; eqab((b&#39;: ℕ) =&gt; P(f b&#39;), pfa)
</span><span id="__span-12-4"><a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a>    }
</span><span id="__span-12-5"><a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a>}
</span></code></pre></div>
</div>

<h3 id="theorem-n-n-0">Theorem: <span class="arithmatex">\(n = n + 0\)</span></h3>
<p>The reverse direction, <span class="arithmatex">\(n = n + 0\)</span>, is derived using the symmetry of equality and the previously proven theorem:</p>
<div class="arithmatex">\[
\forall n \in \mathbb{N}, n = n + 0
\]</div>
<p>This is formalized as:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>def theoremPlusZeroInv: ∀(n: ℕ) -&gt; (n === n + o) = {
</span><span id="__span-13-2"><a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a>    (n: ℕ) =&gt; ℕ.symmetry(n + o, n, theoremPlusZero(n))
</span><span id="__span-13-3"><a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a>}
</span></code></pre></div>
</div>

<h3 id="theorem-successor-and-addition">Theorem: Successor and Addition</h3>
<p>We now prove that for all <span class="arithmatex">\(a, b \in \mathbb{N}\)</span>, the following holds:</p>
<div class="arithmatex">\[
\forall a, b \in \mathbb{N}, S(a + b) = a + S(b)
\]</div>
<p>This is formalized as:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>def theoremPlusSucc: ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (succ(a + b) === a + b.succ) = {
</span><span id="__span-14-2"><a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a>    (a b : ℕ) =&gt; induction(
</span><span id="__span-14-3"><a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a>        (a&#39;: ℕ) =&gt; (succ(a&#39; + b) === a&#39; + b.succ),
</span><span id="__span-14-4"><a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a>        ℕ.refl(succ(o + b)),
</span><span id="__span-14-5"><a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a>        (a&#39;: ℕ, assumption: (succ(a&#39; + b) === a&#39; + b.succ)) =&gt; {
</span><span id="__span-14-6"><a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a>            leibnizEq(succ, succ(a&#39; + b), a&#39; + b.succ, assumption)
</span><span id="__span-14-7"><a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a>        }, a
</span><span id="__span-14-8"><a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a>    )
</span><span id="__span-14-9"><a id="__codelineno-14-9" name="__codelineno-14-9" href="#__codelineno-14-9"></a>}
</span></code></pre></div>
</div>

<ul>
<li><strong>Base Case</strong>: <span class="arithmatex">\(S(0 + b) = 0 + S(b)\)</span>, which holds by reflexivity.</li>
<li><strong>Inductive Step</strong>: Assuming <span class="arithmatex">\(S(a + b) = a + S(b)\)</span>, prove that <span class="arithmatex">\(S(S(a) + b) = S(a) + S(b)\)</span>, using the inductive hypothesis.</li>
</ul>
<h3 id="transitivity-of-equality">Transitivity of Equality</h3>
<p>Equality in type theory satisfies the transitivity property:
$$
\forall a, b, c \in \mathbb{N}, (a = b) \land (b = c) \to a = c
$$
This is formalized as:
$$
\text{transitivity} : \prod_{a, b, c : A} A.Eq(a, b) \to A.Eq(b, c) \to A.Eq(a, c)
$$</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>def transitivity(A: &#39;Type, a b c: A, eqab: A.Eq(a, b), eqbc: A.Eq(b, c)): A.Eq(a, c) = {
</span><span id="__span-15-2"><a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a>    (P: A -&gt; &#39;Type, pa: P(a)) =&gt; eqbc(P, eqab(P, pa))
</span><span id="__span-15-3"><a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a>}
</span></code></pre></div>
</div>

<h3 id="theorem-commutativity-of-addition">Theorem: Commutativity of Addition</h3>
<p>Finally, we prove the commutativity of addition, i.e., for all <span class="arithmatex">\(a, b \in \mathbb{N}\)</span>:
$$
a + b = b + a
$$
This is formalized as:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a>def theoremPlusComm: ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (a + b === b + a) = {
</span><span id="__span-16-2"><a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a>    (a: ℕ, b: ℕ) =&gt; induction(
</span><span id="__span-16-3"><a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a>        (a&#39;: ℕ) =&gt; (a&#39; + b === b + a&#39;),
</span><span id="__span-16-4"><a id="__codelineno-16-4" name="__codelineno-16-4" href="#__codelineno-16-4"></a>        theoremPlusZeroInv b,
</span><span id="__span-16-5"><a id="__codelineno-16-5" name="__codelineno-16-5" href="#__codelineno-16-5"></a>        (a&#39;: ℕ, IH: (a&#39; + b === b + a&#39;)) =&gt; {
</span><span id="__span-16-6"><a id="__codelineno-16-6" name="__codelineno-16-6" href="#__codelineno-16-6"></a>            let eq1 = ℕ.refl(succ(a&#39; + b))                  // succ(a&#39;) + b === succ(a&#39; + b)
</span><span id="__span-16-7"><a id="__codelineno-16-7" name="__codelineno-16-7" href="#__codelineno-16-7"></a>            let eq2 = leibnizEq(succ, a&#39; + b, b + a&#39;, IH)   // succ(a&#39; + b) === succ(b + a&#39;)
</span><span id="__span-16-8"><a id="__codelineno-16-8" name="__codelineno-16-8" href="#__codelineno-16-8"></a>            let eq3 = theoremPlusSucc(b, a&#39;)                // succ(b + a&#39;) === b + succ(a&#39;)
</span><span id="__span-16-9"><a id="__codelineno-16-9" name="__codelineno-16-9" href="#__codelineno-16-9"></a>            let eq4 = transitivity(ℕ, succ(a&#39; + b), succ(b + a&#39;), b + succ(a&#39;), eq2, eq3)
</span><span id="__span-16-10"><a id="__codelineno-16-10" name="__codelineno-16-10" href="#__codelineno-16-10"></a>            transitivity(ℕ, succ(a&#39;) + b, succ(a&#39; + b), b + succ(a&#39;), eq1, eq4)
</span><span id="__span-16-11"><a id="__codelineno-16-11" name="__codelineno-16-11" href="#__codelineno-16-11"></a>        }, a
</span><span id="__span-16-12"><a id="__codelineno-16-12" name="__codelineno-16-12" href="#__codelineno-16-12"></a>    )
</span><span id="__span-16-13"><a id="__codelineno-16-13" name="__codelineno-16-13" href="#__codelineno-16-13"></a>}
</span></code></pre></div>
</div>

<ul>
<li><strong>Base Case</strong>: <span class="arithmatex">\(0 + b = b + 0\)</span>, follows from <span class="arithmatex">\(n + 0 = n\)</span> and <span class="arithmatex">\(n = n + 0\)</span>.</li>
<li><strong>Inductive Step</strong>: Assuming <span class="arithmatex">\(a + b = b + a\)</span>, prove that <span class="arithmatex">\(S(a) + b = b + S(a)\)</span>, using the inductive hypothesis, successor properties, and transitivity of equality.</li>
</ul>
<h2 id="complete-code">Complete Code</h2>
<div class="code-editor" id="code-proof">

<div class="language-text highlight"><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a>def Eq(A: &#39;Type, a b: A): &#39;Type = ∀(P: A -&gt; &#39;Type) -&gt; P(a) -&gt; P(b)
</span><span id="__span-17-2"><a id="__codelineno-17-2" name="__codelineno-17-2" href="#__codelineno-17-2"></a>
</span><span id="__span-17-3"><a id="__codelineno-17-3" name="__codelineno-17-3" href="#__codelineno-17-3"></a>def refl(A: &#39;Type, a: A): A.Eq(a, a) = {
</span><span id="__span-17-4"><a id="__codelineno-17-4" name="__codelineno-17-4" href="#__codelineno-17-4"></a>    (P: A -&gt; &#39;Type, pa: P(a)) =&gt; pa
</span><span id="__span-17-5"><a id="__codelineno-17-5" name="__codelineno-17-5" href="#__codelineno-17-5"></a>}
</span><span id="__span-17-6"><a id="__codelineno-17-6" name="__codelineno-17-6" href="#__codelineno-17-6"></a>
</span><span id="__span-17-7"><a id="__codelineno-17-7" name="__codelineno-17-7" href="#__codelineno-17-7"></a>def symmetry(A: &#39;Type, a b: A, eqab: A.Eq(a, b)): A.Eq(b, a) = {
</span><span id="__span-17-8"><a id="__codelineno-17-8" name="__codelineno-17-8" href="#__codelineno-17-8"></a>    eqab((b&#39;: A) =&gt; A.Eq(b&#39;, a), A.refl(a))
</span><span id="__span-17-9"><a id="__codelineno-17-9" name="__codelineno-17-9" href="#__codelineno-17-9"></a>}
</span><span id="__span-17-10"><a id="__codelineno-17-10" name="__codelineno-17-10" href="#__codelineno-17-10"></a>
</span><span id="__span-17-11"><a id="__codelineno-17-11" name="__codelineno-17-11" href="#__codelineno-17-11"></a>type ℕ = inductive {
</span><span id="__span-17-12"><a id="__codelineno-17-12" name="__codelineno-17-12" href="#__codelineno-17-12"></a>    Zero
</span><span id="__span-17-13"><a id="__codelineno-17-13" name="__codelineno-17-13" href="#__codelineno-17-13"></a>    Succ(ℕ)
</span><span id="__span-17-14"><a id="__codelineno-17-14" name="__codelineno-17-14" href="#__codelineno-17-14"></a>}
</span><span id="__span-17-15"><a id="__codelineno-17-15" name="__codelineno-17-15" href="#__codelineno-17-15"></a>
</span><span id="__span-17-16"><a id="__codelineno-17-16" name="__codelineno-17-16" href="#__codelineno-17-16"></a>def o: ℕ = ℕ::Zero
</span><span id="__span-17-17"><a id="__codelineno-17-17" name="__codelineno-17-17" href="#__codelineno-17-17"></a>def succ(n: ℕ): ℕ = ℕ::Succ(n)
</span><span id="__span-17-18"><a id="__codelineno-17-18" name="__codelineno-17-18" href="#__codelineno-17-18"></a>
</span><span id="__span-17-19"><a id="__codelineno-17-19" name="__codelineno-17-19" href="#__codelineno-17-19"></a>operator binary (===) left-assoc {
</span><span id="__span-17-20"><a id="__codelineno-17-20" name="__codelineno-17-20" href="#__codelineno-17-20"></a>    looser-than (+)
</span><span id="__span-17-21"><a id="__codelineno-17-21" name="__codelineno-17-21" href="#__codelineno-17-21"></a>}
</span><span id="__span-17-22"><a id="__codelineno-17-22" name="__codelineno-17-22" href="#__codelineno-17-22"></a>
</span><span id="__span-17-23"><a id="__codelineno-17-23" name="__codelineno-17-23" href="#__codelineno-17-23"></a>def (===)(a b: ℕ): &#39;Type = ℕ.Eq(a, b)
</span><span id="__span-17-24"><a id="__codelineno-17-24" name="__codelineno-17-24" href="#__codelineno-17-24"></a>
</span><span id="__span-17-25"><a id="__codelineno-17-25" name="__codelineno-17-25" href="#__codelineno-17-25"></a>def (+)(a b : ℕ): ℕ = match a {
</span><span id="__span-17-26"><a id="__codelineno-17-26" name="__codelineno-17-26" href="#__codelineno-17-26"></a>    case ℕ::Zero =&gt; b
</span><span id="__span-17-27"><a id="__codelineno-17-27" name="__codelineno-17-27" href="#__codelineno-17-27"></a>    case ℕ::Succ(a&#39;) =&gt; ℕ::Succ(a&#39; + b)
</span><span id="__span-17-28"><a id="__codelineno-17-28" name="__codelineno-17-28" href="#__codelineno-17-28"></a>}
</span><span id="__span-17-29"><a id="__codelineno-17-29" name="__codelineno-17-29" href="#__codelineno-17-29"></a>
</span><span id="__span-17-30"><a id="__codelineno-17-30" name="__codelineno-17-30" href="#__codelineno-17-30"></a>def induction(
</span><span id="__span-17-31"><a id="__codelineno-17-31" name="__codelineno-17-31" href="#__codelineno-17-31"></a>    P: ℕ -&gt; &#39;Type,
</span><span id="__span-17-32"><a id="__codelineno-17-32" name="__codelineno-17-32" href="#__codelineno-17-32"></a>    base: P(ℕ::Zero),
</span><span id="__span-17-33"><a id="__codelineno-17-33" name="__codelineno-17-33" href="#__codelineno-17-33"></a>    induce: ∀(n: ℕ) -&gt; P(n) -&gt; P(n.succ),
</span><span id="__span-17-34"><a id="__codelineno-17-34" name="__codelineno-17-34" href="#__codelineno-17-34"></a>    nat: ℕ,
</span><span id="__span-17-35"><a id="__codelineno-17-35" name="__codelineno-17-35" href="#__codelineno-17-35"></a>): P(nat) = match nat {
</span><span id="__span-17-36"><a id="__codelineno-17-36" name="__codelineno-17-36" href="#__codelineno-17-36"></a>    case ℕ::Zero =&gt; base
</span><span id="__span-17-37"><a id="__codelineno-17-37" name="__codelineno-17-37" href="#__codelineno-17-37"></a>    case ℕ::Succ(n&#39;) =&gt; induce(n&#39;, P.induction(base, induce, n&#39;))
</span><span id="__span-17-38"><a id="__codelineno-17-38" name="__codelineno-17-38" href="#__codelineno-17-38"></a>}
</span><span id="__span-17-39"><a id="__codelineno-17-39" name="__codelineno-17-39" href="#__codelineno-17-39"></a>
</span><span id="__span-17-40"><a id="__codelineno-17-40" name="__codelineno-17-40" href="#__codelineno-17-40"></a>def inductionReduce(
</span><span id="__span-17-41"><a id="__codelineno-17-41" name="__codelineno-17-41" href="#__codelineno-17-41"></a>    a b: ℕ,
</span><span id="__span-17-42"><a id="__codelineno-17-42" name="__codelineno-17-42" href="#__codelineno-17-42"></a>    eqba: (b === a),
</span><span id="__span-17-43"><a id="__codelineno-17-43" name="__codelineno-17-43" href="#__codelineno-17-43"></a>    P: ℕ -&gt; &#39;Type,
</span><span id="__span-17-44"><a id="__codelineno-17-44" name="__codelineno-17-44" href="#__codelineno-17-44"></a>    pa: P(a),
</span><span id="__span-17-45"><a id="__codelineno-17-45" name="__codelineno-17-45" href="#__codelineno-17-45"></a>): P(b) = {
</span><span id="__span-17-46"><a id="__codelineno-17-46" name="__codelineno-17-46" href="#__codelineno-17-46"></a>    let eqab = ℕ.symmetry(b, a, eqba)
</span><span id="__span-17-47"><a id="__codelineno-17-47" name="__codelineno-17-47" href="#__codelineno-17-47"></a>    eqab(P, pa)
</span><span id="__span-17-48"><a id="__codelineno-17-48" name="__codelineno-17-48" href="#__codelineno-17-48"></a>}
</span><span id="__span-17-49"><a id="__codelineno-17-49" name="__codelineno-17-49" href="#__codelineno-17-49"></a>
</span><span id="__span-17-50"><a id="__codelineno-17-50" name="__codelineno-17-50" href="#__codelineno-17-50"></a>def theoremPlusZero: ∀(n: ℕ) -&gt; (n + o === n) = {
</span><span id="__span-17-51"><a id="__codelineno-17-51" name="__codelineno-17-51" href="#__codelineno-17-51"></a>    ((n: ℕ) =&gt; (n + o === n)).induction(
</span><span id="__span-17-52"><a id="__codelineno-17-52" name="__codelineno-17-52" href="#__codelineno-17-52"></a>        ℕ.refl(ℕ::Zero),
</span><span id="__span-17-53"><a id="__codelineno-17-53" name="__codelineno-17-53" href="#__codelineno-17-53"></a>        (n: ℕ, assumption: (n + o === n)) =&gt; {
</span><span id="__span-17-54"><a id="__codelineno-17-54" name="__codelineno-17-54" href="#__codelineno-17-54"></a>            inductionReduce(
</span><span id="__span-17-55"><a id="__codelineno-17-55" name="__codelineno-17-55" href="#__codelineno-17-55"></a>                n, n + o, assumption,
</span><span id="__span-17-56"><a id="__codelineno-17-56" name="__codelineno-17-56" href="#__codelineno-17-56"></a>                (n&#39;: ℕ) =&gt; (n&#39;.succ === n.succ),
</span><span id="__span-17-57"><a id="__codelineno-17-57" name="__codelineno-17-57" href="#__codelineno-17-57"></a>                ℕ.refl(n.succ)
</span><span id="__span-17-58"><a id="__codelineno-17-58" name="__codelineno-17-58" href="#__codelineno-17-58"></a>            )
</span><span id="__span-17-59"><a id="__codelineno-17-59" name="__codelineno-17-59" href="#__codelineno-17-59"></a>        }
</span><span id="__span-17-60"><a id="__codelineno-17-60" name="__codelineno-17-60" href="#__codelineno-17-60"></a>    )
</span><span id="__span-17-61"><a id="__codelineno-17-61" name="__codelineno-17-61" href="#__codelineno-17-61"></a>}
</span><span id="__span-17-62"><a id="__codelineno-17-62" name="__codelineno-17-62" href="#__codelineno-17-62"></a>
</span><span id="__span-17-63"><a id="__codelineno-17-63" name="__codelineno-17-63" href="#__codelineno-17-63"></a>def leibnizEq(f: ℕ -&gt; ℕ): ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (a === b) -&gt; (f(a) === f(b)) = {
</span><span id="__span-17-64"><a id="__codelineno-17-64" name="__codelineno-17-64" href="#__codelineno-17-64"></a>    (a b : ℕ, eqab: (a === b)) =&gt; {
</span><span id="__span-17-65"><a id="__codelineno-17-65" name="__codelineno-17-65" href="#__codelineno-17-65"></a>        (P: ℕ -&gt; &#39;Type, pfa: P(f a)) =&gt; eqab((b&#39;: ℕ) =&gt; P(f b&#39;), pfa)
</span><span id="__span-17-66"><a id="__codelineno-17-66" name="__codelineno-17-66" href="#__codelineno-17-66"></a>    }
</span><span id="__span-17-67"><a id="__codelineno-17-67" name="__codelineno-17-67" href="#__codelineno-17-67"></a>}
</span><span id="__span-17-68"><a id="__codelineno-17-68" name="__codelineno-17-68" href="#__codelineno-17-68"></a>
</span><span id="__span-17-69"><a id="__codelineno-17-69" name="__codelineno-17-69" href="#__codelineno-17-69"></a>def theoremPlusZeroInv: ∀(n: ℕ) -&gt; (n === n + o) = {
</span><span id="__span-17-70"><a id="__codelineno-17-70" name="__codelineno-17-70" href="#__codelineno-17-70"></a>    (n: ℕ) =&gt; ℕ.symmetry(n + o, n, theoremPlusZero(n))
</span><span id="__span-17-71"><a id="__codelineno-17-71" name="__codelineno-17-71" href="#__codelineno-17-71"></a>}
</span><span id="__span-17-72"><a id="__codelineno-17-72" name="__codelineno-17-72" href="#__codelineno-17-72"></a>
</span><span id="__span-17-73"><a id="__codelineno-17-73" name="__codelineno-17-73" href="#__codelineno-17-73"></a>def theoremPlusSucc: ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (succ(a + b) === a + b.succ) = {
</span><span id="__span-17-74"><a id="__codelineno-17-74" name="__codelineno-17-74" href="#__codelineno-17-74"></a>    (a b : ℕ) =&gt; induction(
</span><span id="__span-17-75"><a id="__codelineno-17-75" name="__codelineno-17-75" href="#__codelineno-17-75"></a>        (a&#39;: ℕ) =&gt; (succ(a&#39; + b) === a&#39; + b.succ),
</span><span id="__span-17-76"><a id="__codelineno-17-76" name="__codelineno-17-76" href="#__codelineno-17-76"></a>        ℕ.refl(succ(o + b)),
</span><span id="__span-17-77"><a id="__codelineno-17-77" name="__codelineno-17-77" href="#__codelineno-17-77"></a>        (a&#39;: ℕ, assumption: (succ(a&#39; + b) === a&#39; + b.succ)) =&gt; {
</span><span id="__span-17-78"><a id="__codelineno-17-78" name="__codelineno-17-78" href="#__codelineno-17-78"></a>            leibnizEq(succ, succ(a&#39; + b), a&#39; + b.succ, assumption)
</span><span id="__span-17-79"><a id="__codelineno-17-79" name="__codelineno-17-79" href="#__codelineno-17-79"></a>        }, a
</span><span id="__span-17-80"><a id="__codelineno-17-80" name="__codelineno-17-80" href="#__codelineno-17-80"></a>    )
</span><span id="__span-17-81"><a id="__codelineno-17-81" name="__codelineno-17-81" href="#__codelineno-17-81"></a>}
</span><span id="__span-17-82"><a id="__codelineno-17-82" name="__codelineno-17-82" href="#__codelineno-17-82"></a>
</span><span id="__span-17-83"><a id="__codelineno-17-83" name="__codelineno-17-83" href="#__codelineno-17-83"></a>def transitivity(A: &#39;Type, a b c: A, eqab: A.Eq(a, b), eqbc: A.Eq(b, c)): A.Eq(a, c) = {
</span><span id="__span-17-84"><a id="__codelineno-17-84" name="__codelineno-17-84" href="#__codelineno-17-84"></a>    (P: A -&gt; &#39;Type, pa: P(a)) =&gt; eqbc(P, eqab(P, pa))
</span><span id="__span-17-85"><a id="__codelineno-17-85" name="__codelineno-17-85" href="#__codelineno-17-85"></a>}
</span><span id="__span-17-86"><a id="__codelineno-17-86" name="__codelineno-17-86" href="#__codelineno-17-86"></a>
</span><span id="__span-17-87"><a id="__codelineno-17-87" name="__codelineno-17-87" href="#__codelineno-17-87"></a>def theoremPlusComm: ∀(a: ℕ) -&gt; ∀(b: ℕ) -&gt; (a + b === b + a) = {
</span><span id="__span-17-88"><a id="__codelineno-17-88" name="__codelineno-17-88" href="#__codelineno-17-88"></a>    (a: ℕ, b: ℕ) =&gt; induction(
</span><span id="__span-17-89"><a id="__codelineno-17-89" name="__codelineno-17-89" href="#__codelineno-17-89"></a>        (a&#39;: ℕ) =&gt; (a&#39; + b === b + a&#39;),
</span><span id="__span-17-90"><a id="__codelineno-17-90" name="__codelineno-17-90" href="#__codelineno-17-90"></a>        theoremPlusZeroInv b,
</span><span id="__span-17-91"><a id="__codelineno-17-91" name="__codelineno-17-91" href="#__codelineno-17-91"></a>        (a&#39;: ℕ, IH: (a&#39; + b === b + a&#39;)) =&gt; {
</span><span id="__span-17-92"><a id="__codelineno-17-92" name="__codelineno-17-92" href="#__codelineno-17-92"></a>            let eq1 = ℕ.refl(succ(a&#39; + b))                  // succ(a&#39;) + b === succ(a&#39; + b)
</span><span id="__span-17-93"><a id="__codelineno-17-93" name="__codelineno-17-93" href="#__codelineno-17-93"></a>            let eq2 = leibnizEq(succ, a&#39; + b, b + a&#39;, IH)   // succ(a&#39; + b) === succ(b + a&#39;)
</span><span id="__span-17-94"><a id="__codelineno-17-94" name="__codelineno-17-94" href="#__codelineno-17-94"></a>            let eq3 = theoremPlusSucc(b, a&#39;)                // succ(b + a&#39;) === b + succ(a&#39;)
</span><span id="__span-17-95"><a id="__codelineno-17-95" name="__codelineno-17-95" href="#__codelineno-17-95"></a>            let eq4 = transitivity(ℕ, succ(a&#39; + b), succ(b + a&#39;), b + succ(a&#39;), eq2, eq3)
</span><span id="__span-17-96"><a id="__codelineno-17-96" name="__codelineno-17-96" href="#__codelineno-17-96"></a>            transitivity(ℕ, succ(a&#39;) + b, succ(a&#39; + b), b + succ(a&#39;), eq1, eq4)
</span><span id="__span-17-97"><a id="__codelineno-17-97" name="__codelineno-17-97" href="#__codelineno-17-97"></a>        }, a
</span><span id="__span-17-98"><a id="__codelineno-17-98" name="__codelineno-17-98" href="#__codelineno-17-98"></a>    )
</span><span id="__span-17-99"><a id="__codelineno-17-99" name="__codelineno-17-99" href="#__codelineno-17-99"></a>}
</span><span id="__span-17-100"><a id="__codelineno-17-100" name="__codelineno-17-100" href="#__codelineno-17-100"></a>
</span><span id="__span-17-101"><a id="__codelineno-17-101" name="__codelineno-17-101" href="#__codelineno-17-101"></a>eval &quot;∀(n: ℕ), n + 0 = n&quot;
</span><span id="__span-17-102"><a id="__codelineno-17-102" name="__codelineno-17-102" href="#__codelineno-17-102"></a>eval theoremPlusZero
</span><span id="__span-17-103"><a id="__codelineno-17-103" name="__codelineno-17-103" href="#__codelineno-17-103"></a>
</span><span id="__span-17-104"><a id="__codelineno-17-104" name="__codelineno-17-104" href="#__codelineno-17-104"></a>eval &quot;&quot;
</span><span id="__span-17-105"><a id="__codelineno-17-105" name="__codelineno-17-105" href="#__codelineno-17-105"></a>
</span><span id="__span-17-106"><a id="__codelineno-17-106" name="__codelineno-17-106" href="#__codelineno-17-106"></a>eval &quot;∀(a b : ℕ), S(a + b) = a + S(b)&quot;
</span><span id="__span-17-107"><a id="__codelineno-17-107" name="__codelineno-17-107" href="#__codelineno-17-107"></a>eval theoremPlusSucc
</span><span id="__span-17-108"><a id="__codelineno-17-108" name="__codelineno-17-108" href="#__codelineno-17-108"></a>
</span><span id="__span-17-109"><a id="__codelineno-17-109" name="__codelineno-17-109" href="#__codelineno-17-109"></a>eval &quot;&quot;
</span><span id="__span-17-110"><a id="__codelineno-17-110" name="__codelineno-17-110" href="#__codelineno-17-110"></a>
</span><span id="__span-17-111"><a id="__codelineno-17-111" name="__codelineno-17-111" href="#__codelineno-17-111"></a>eval &quot;∀(a b : ℕ), a + b = b + a&quot;
</span><span id="__span-17-112"><a id="__codelineno-17-112" name="__codelineno-17-112" href="#__codelineno-17-112"></a>eval theoremPlusComm
</span></code></pre></div>
</div>

<div class="button-container">
    <button class="md-button button-run" onclick="runCodeInEditor('code-proof', 'output-proof')">Run Type Checker</button>
</div>

<div class="result-editor" id="output-proof"></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.action.edit", "navigation.expand"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="../javascripts/editor.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>