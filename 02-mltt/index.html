
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../01-keywords/">
      
      
        <link rel="next" href="../03-proofs/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.44">
    
    
      
        <title>Martin-Löf Type Theory - Saki-Lang</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#martin-lof-type-theory" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Saki-Lang" class="md-header__button md-logo" aria-label="Saki-Lang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 3h2v2H5v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5h2v2H5c-1.07-.27-2-.9-2-2v-4a2 2 0 0 0-2-2H0v-2h1a2 2 0 0 0 2-2V5a2 2 0 0 1 2-2m14 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-5a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3zm-7 12a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m-4 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m8 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Saki-Lang
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Martin-Löf Type Theory
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Saki-Lang" class="md-nav__button md-logo" aria-label="Saki-Lang" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 3h2v2H5v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5h2v2H5c-1.07-.27-2-.9-2-2v-4a2 2 0 0 0-2-2H0v-2h1a2 2 0 0 0 2-2V5a2 2 0 0 1 2-2m14 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-5a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3zm-7 12a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m-4 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1m8 0a1 1 0 0 1 1 1 1 1 0 0 1-1 1 1 1 0 0 1-1-1 1 1 0 0 1 1-1"/></svg>

    </a>
    Saki-Lang
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Introduction
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-keywords/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Keywords and Identifiers
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Martin-Löf Type Theory
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Martin-Löf Type Theory
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#background-and-motivation" class="md-nav__link">
    <span class="md-ellipsis">
      Background and Motivation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Background and Motivation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#constructive-mathematics-and-computation" class="md-nav__link">
    <span class="md-ellipsis">
      Constructive Mathematics and Computation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-curry-howard-correspondence" class="md-nav__link">
    <span class="md-ellipsis">
      The Curry-Howard Correspondence
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dependent-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Dependent Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dependent-function-types-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Function Types (Π-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependent-pair-types-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Pair Types (Σ-Types)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#universes-and-type-hierarchies" class="md-nav__link">
    <span class="md-ellipsis">
      Universes and Type Hierarchies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#syntax-of-martin-lof-type-theory" class="md-nav__link">
    <span class="md-ellipsis">
      Syntax of Martin-Löf Type Theory
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-by-evaluation-nbe" class="md-nav__link">
    <span class="md-ellipsis">
      Normalization by Evaluation (NBE)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Normalization by Evaluation (NBE)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#values-and-neutral-values" class="md-nav__link">
    <span class="md-ellipsis">
      Values and Neutral Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#environments-and-closures" class="md-nav__link">
    <span class="md-ellipsis">
      Environments and Closures
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      Evaluation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reification-read-back" class="md-nav__link">
    <span class="md-ellipsis">
      Reification (Read-Back)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#neutral-value-reification" class="md-nav__link">
    <span class="md-ellipsis">
      Neutral Value Reification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formalization-of-nbes-core-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Formalization of NBE’s Core Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Formalization of NBE’s Core Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#evaluation-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Evaluation Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#application-in-formal-terms" class="md-nav__link">
    <span class="md-ellipsis">
      Application in Formal Terms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#complete-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      Complete Implementation
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-proofs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Construct Formal Proofs
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-overloading/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ad-Hoc Polymorphism (Overloading)
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-subtyping/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Subtyping and Algebraic Subtyping
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Definition
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Definition
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Definition/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Definition
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Definition/01-decorator/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Decorator
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Terms
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Terms
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Terms
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/01-lambda/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Function (Lambda)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/02-dependent-pi/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dependent Pi (Function) Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/04-expr/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Expressions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/05-sum/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sum Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/06-pair/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Product Type (Pair) and Dependent Sigma Type
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/07-record/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Record
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/08-adt/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Algebraic Datatype
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/09-inductive/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Inductive Type with Indices
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Terms/10-constraint/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Constraint Universe
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#background-and-motivation" class="md-nav__link">
    <span class="md-ellipsis">
      Background and Motivation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Background and Motivation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#constructive-mathematics-and-computation" class="md-nav__link">
    <span class="md-ellipsis">
      Constructive Mathematics and Computation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-curry-howard-correspondence" class="md-nav__link">
    <span class="md-ellipsis">
      The Curry-Howard Correspondence
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dependent-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Types
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Dependent Types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dependent-function-types-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Function Types (Π-Types)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependent-pair-types-types" class="md-nav__link">
    <span class="md-ellipsis">
      Dependent Pair Types (Σ-Types)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#universes-and-type-hierarchies" class="md-nav__link">
    <span class="md-ellipsis">
      Universes and Type Hierarchies
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#syntax-of-martin-lof-type-theory" class="md-nav__link">
    <span class="md-ellipsis">
      Syntax of Martin-Löf Type Theory
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-by-evaluation-nbe" class="md-nav__link">
    <span class="md-ellipsis">
      Normalization by Evaluation (NBE)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Normalization by Evaluation (NBE)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#values-and-neutral-values" class="md-nav__link">
    <span class="md-ellipsis">
      Values and Neutral Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#environments-and-closures" class="md-nav__link">
    <span class="md-ellipsis">
      Environments and Closures
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      Evaluation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reification-read-back" class="md-nav__link">
    <span class="md-ellipsis">
      Reification (Read-Back)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#neutral-value-reification" class="md-nav__link">
    <span class="md-ellipsis">
      Neutral Value Reification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formalization-of-nbes-core-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Formalization of NBE’s Core Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Formalization of NBE’s Core Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#evaluation-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Evaluation Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#application-in-formal-terms" class="md-nav__link">
    <span class="md-ellipsis">
      Application in Formal Terms
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#complete-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      Complete Implementation
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="martin-lof-type-theory">Martin-Löf Type Theory</h1>
<script type="module" src="/javascripts/editor.js"></script>
<p><link rel="stylesheet" href="/static/styles.css"></p>
<p>Martin-Löf Type Theory (MLTT) stands as a foundational system intertwining constructive mathematics and computer science, developed by Per Martin-Löf in the 1970s. It offers a framework where logic and computation are unified, serving both as a formal language for mathematical proofs and as a typed functional programming language. The hallmark of MLTT is its use of <strong>dependent types</strong>, which enhances the expressiveness of the type system by allowing types to depend on terms. This introduction delves into the theoretical underpinnings of MLTT, emphasizing the role and implications of dependent types within the system.</p>
<h2 id="background-and-motivation">Background and Motivation</h2>
<h3 id="constructive-mathematics-and-computation">Constructive Mathematics and Computation</h3>
<p>Constructive mathematics emphasizes the necessity of constructing mathematical objects explicitly rather than assuming their existence non-constructively. This approach aligns naturally with computation, where mathematical proofs correspond to algorithms, and existence proofs provide methods to compute the objects in question.</p>
<h3 id="the-curry-howard-correspondence">The Curry-Howard Correspondence</h3>
<p>The Curry-Howard correspondence establishes a profound connection between logic and computation, interpreting types as propositions and terms as proofs or programs. In this paradigm:</p>
<ul>
<li><strong>Types ≈ Propositions</strong></li>
<li><strong>Terms ≈ Proofs/Programs</strong></li>
<li><strong>Type Checking ≈ Proof Verification</strong></li>
<li><strong>Program Execution ≈ Proof Normalization</strong></li>
</ul>
<p>MLTT extends this correspondence by incorporating dependent types, allowing for more expressive propositions and enabling the representation of intricate mathematical concepts within the type system.</p>
<h2 id="dependent-types">Dependent Types</h2>
<h3 id="dependent-function-types-types">Dependent Function Types (Π-Types)</h3>
<p><strong>Formation Rule</strong>:</p>
<div class="arithmatex">\[
\frac{\Gamma \vdash A : \mathcal{U} \quad \Gamma, x : A \vdash B(x) : \mathcal{U}}{\Gamma \vdash \Pi(x : A) . B(x) : \mathcal{U}}
\]</div>
<p><strong>Introduction Rule</strong>:</p>
<div class="arithmatex">\[
\frac{\Gamma, x : A \vdash b(x) : B(x)}{\Gamma \vdash \lambda x. b(x) : \Pi(x : A) . B(x)}
\]</div>
<p><strong>Elimination Rule (Application)</strong>:</p>
<div class="arithmatex">\[
\frac{\Gamma \vdash f : \Pi(x : A) . B(x) \quad \Gamma \vdash a : A}{\Gamma \vdash f(a) : B(a)}
\]</div>
<h3 id="dependent-pair-types-types">Dependent Pair Types (Σ-Types)</h3>
<p><strong>Formation Rule</strong>:</p>
<div class="arithmatex">\[
\frac{\Gamma \vdash A : \mathcal{U} \quad \Gamma, x : A \vdash B(x) : \mathcal{U}}{\Gamma \vdash \Sigma(x : A) . B(x) : \mathcal{U}}
\]</div>
<p><strong>Introduction Rule</strong>:</p>
<div class="arithmatex">\[
\frac{\Gamma \vdash a : A \quad \Gamma \vdash b : B(a)}{\Gamma \vdash (a, b) : \Sigma(x : A) . B(x)}
\]</div>
<p><strong>Elimination Rules (Projections)</strong>:</p>
<p>For <span class="arithmatex">\(p : (\Sigma x : A) B(x)\)</span>:</p>
<ul>
<li><strong>First Projection</strong>: <span class="arithmatex">\(\text{fst}(p) : A\)</span></li>
<li><strong>Second Projection</strong>: <span class="arithmatex">\(\text{snd}(p) : B(\text{fst}(p))\)</span></li>
</ul>
<h2 id="universes-and-type-hierarchies">Universes and Type Hierarchies</h2>
<p>To prevent paradoxes such as Girard's paradox, MLTT introduces a hierarchy of universes:</p>
<ul>
<li><strong>Type Universes</strong> (<span class="arithmatex">\(\mathcal{U}_0, \mathcal{U}_1, \ldots\)</span>): Each universe <span class="arithmatex">\(\mathcal{U}_i\)</span> is a type whose elements are types in the universe <span class="arithmatex">\(\mathcal{U}_{i-1}\)</span>.</li>
<li><strong>Cumulativity</strong>: If <span class="arithmatex">\(A : \mathcal{U}_i\)</span>, then <span class="arithmatex">\(A : \mathcal{U}_{i+1}\)</span>.</li>
</ul>
<p>This stratification ensures the consistency of the type theory by avoiding circular definitions.</p>
<h2 id="syntax-of-martin-lof-type-theory">Syntax of Martin-Löf Type Theory</h2>
<p>To formalize the discussion, we present the syntax of MLTT, focusing on constructs related to dependent types:</p>
<div class="arithmatex">\[
\begin{array}{lcll}
t, u &amp; ::= &amp; x &amp; \text{Variable} \\ 
&amp; | &amp; \mathcal{U} &amp; \text{Universe} \\
&amp; | &amp; \Pi(x: t).u &amp; \text{Dependent Pi Type} \\
&amp; | &amp; \Sigma(x: t).u &amp; \text{Dependent Sigma Type} \\
&amp; | &amp; \lambda(x: t).u &amp; \text{Lambda Expression} \\
&amp; | &amp; t \ u &amp; \text{Application} \\
&amp; | &amp; (t, u) &amp; \text{Pair} \\
&amp; | &amp; \text{fst}(t) &amp; \text{First Projection} \\
&amp; | &amp; \text{snd}(t) &amp; \text{Second Projection} \\
\end{array}
\]</div>
<p>In this syntax:</p>
<ul>
<li><strong>Variables</strong> (<span class="arithmatex">\( x \)</span>) represent identifiers.</li>
<li><strong>Universes</strong> (<span class="arithmatex">\( \mathcal{U} \)</span>) represent types of types, introducing a hierarchy to prevent paradoxes.</li>
<li><strong>Dependent Pi Types</strong> (<span class="arithmatex">\( \Pi(x: t).u \)</span>) generalize function types, allowing the return type <span class="arithmatex">\( u \)</span> to depend on the input <span class="arithmatex">\( x \)</span>.</li>
<li><strong>Dependent Sigma Types</strong> (<span class="arithmatex">\( \Sigma(x: t).u \)</span>) represent dependent pairs, where the second component depends on the first.</li>
<li><strong>Lambda Expressions</strong> (<span class="arithmatex">\( \lambda(x: t).u \)</span>) define functions with parameter <span class="arithmatex">\( x \)</span> of type <span class="arithmatex">\( t \)</span> and body <span class="arithmatex">\( u \)</span>.</li>
<li><strong>Applications</strong> (<span class="arithmatex">\( t \ u \)</span>) apply functions to arguments.</li>
<li><strong>Pairs</strong> (<span class="arithmatex">\( (t, u) \)</span>) create dependent pairs.</li>
<li><strong>Projections</strong> (<span class="arithmatex">\( \text{fst}(t) \)</span> and <span class="arithmatex">\( \text{snd}(t) \)</span>) extract the first and second components of a pair.</li>
</ul>
<p>To further elucidate the structure of terms in MLTT, we can represent them using an inductive data type:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>type Term = inductive {
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>    // Variable: Represents a variable identified by its name.
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>    Var(String)
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>    // Universe Level: Represents types at a certain universe level.
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>    Type(Int)
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>    // Dependent Pi Type: `Π(x : A). B`, where `B` may depend on `x`.
</span><span id="__span-0-7"><a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>    Pi(String, Term, Term)
</span><span id="__span-0-8"><a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>    // Lambda Term: `λ(x : A). t`.
</span><span id="__span-0-9"><a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>    Lambda(String, Term, Term)
</span><span id="__span-0-10"><a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a>    // Application: Applying a function to an argument.
</span><span id="__span-0-11"><a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a>    Apply(Term, Term)
</span><span id="__span-0-12"><a id="__codelineno-0-12" name="__codelineno-0-12" href="#__codelineno-0-12"></a>    // Sigma Type: `Σ(x : A). B`, a dependent pair type.
</span><span id="__span-0-13"><a id="__codelineno-0-13" name="__codelineno-0-13" href="#__codelineno-0-13"></a>    Sigma(String, Term, Term)
</span><span id="__span-0-14"><a id="__codelineno-0-14" name="__codelineno-0-14" href="#__codelineno-0-14"></a>    // Pair Term: `(a, b)`.
</span><span id="__span-0-15"><a id="__codelineno-0-15" name="__codelineno-0-15" href="#__codelineno-0-15"></a>    Pair(Term, Term)
</span><span id="__span-0-16"><a id="__codelineno-0-16" name="__codelineno-0-16" href="#__codelineno-0-16"></a>    // Projection: Extracting the first or second element of a pair.
</span><span id="__span-0-17"><a id="__codelineno-0-17" name="__codelineno-0-17" href="#__codelineno-0-17"></a>    Proj(Projection, Term)
</span><span id="__span-0-18"><a id="__codelineno-0-18" name="__codelineno-0-18" href="#__codelineno-0-18"></a>}
</span></code></pre></div>
</div>

<h2 id="normalization-by-evaluation-nbe">Normalization by Evaluation (NBE)</h2>
<p>Evaluation in MLTT aims to reduce terms to their normal forms, or fully simplified versions. The process involves translating syntactic terms into a structured representation that allows terms with bound variables to be resolved efficiently. Traditional reduction-based evaluation relies on direct substitution and can be inefficient. Normalization by Evaluation (NBE), however, uses an environment to track bindings and reification to convert values back into terms. It differs fundamentally from direct reduction methods by bypassing substitution and instead leveraging environments and reification to achieve efficient normalization of terms to their irreducible, or normal forms. NBE is especially advantageous in dependent type theories, where terms can depend on values, and normalization is essential for type-checking and proof verification. </p>
<h3 id="values-and-neutral-values">Values and Neutral Values</h3>
<p><em>Values</em> in NBE are representations of terms that can fully evaluate within an environment, encompassing functions, constants, and closed expressions.</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>type Value = inductive {
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>    // Neutral Value: A value that cannot be reduced further
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>    Neutral(NeutralValue)
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>    // Universe Level: A type at a specific universe level.
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>    Type(Int)
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>    // Lambda Function: A function value with its parameter type and body.
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a>    Lambda(Value, Value -&gt; Value)
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>    // Pi Type Value: Represents a dependent function type.
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a>    Pi(Value, Value -&gt; Value)
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a>    // Sigma Type Value: Represents a dependent pair type.
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a>    Sigma(Value, Value -&gt; Value)
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a>    // Pair Value: A pair of values.
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a>    Pair(Value, Value)
</span><span id="__span-1-14"><a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a>}
</span><span id="__span-1-15"><a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a>
</span><span id="__span-1-16"><a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a>// In this implementation, types are represented as values.
</span><span id="__span-1-17"><a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a>type Type = Value
</span></code></pre></div>
</div>

<p><em>Neutral values</em>, however, represent terms that are blocked from further reduction due to free variables or unsolved dependencies. Neutral values allow terms with unresolved components to be stored without forcing premature reductions. They are especially significant in representing expressions that cannot simplify further because they involve variables that are free in the current context.</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>type NeutralValue = inductive {
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>    // Variable: A neutral value representing an unresolved variable.
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>    Var(String)
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>    // Application: Applying a neutral function to a value.
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>    Apply(NeutralValue, Value)
</span><span id="__span-2-6"><a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a>    // Projection: Extracting the first or second element of a pair.
</span><span id="__span-2-7"><a id="__codelineno-2-7" name="__codelineno-2-7" href="#__codelineno-2-7"></a>    Proj(Projection, NeutralValue)
</span><span id="__span-2-8"><a id="__codelineno-2-8" name="__codelineno-2-8" href="#__codelineno-2-8"></a>}
</span></code></pre></div>
</div>

<h3 id="environments-and-closures">Environments and Closures</h3>
<p>In NBE, functions are represented as closures, capturing both the function body and its environment. An environment binds variables to values, avoiding the need for explicit substitution and enhancing the efficiency of evaluation.</p>
<p>For instance, if a term <code>λx.t</code> is in the environment <code>Env</code>, it can be represented as a closure combining <code>t</code> with <code>Env</code>. This representation enables the function to retain variable bindings even as it passes through various stages of evaluation.</p>
<p>For simplicity, we use a linked list to implement the environment and lambda functions in the host language to represent closures:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>type Env = inductive {
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>    Empty
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>    Cons(String, TypedValue, Env)
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>}
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>type Value = inductive {
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a>    /* ... */
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a>    Lambda(Value, Value -&gt; Value)
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a>    Pi(Value, Value -&gt; Value)
</span><span id="__span-3-10"><a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a>    Sigma(Value, Value -&gt; Value)
</span><span id="__span-3-11"><a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a>}
</span></code></pre></div>
</div>

<h3 id="evaluation">Evaluation</h3>
<p>Evaluation in NBE converts syntactic terms into a structured representation of values. Each variable is looked up in the environment rather than being substituted directly, streamlining the process. Below is a function implementing this evaluation, handling variables, functions, and applications:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>def evaluate(env: Env, expr: Term): Value = match expr {
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>    // Look up the variable&#39;s value.
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>    case Term::Var(name) =&gt; env.get(name).unwrap[TypedValue].value
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>    // A type evaluates to itself.
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>    case Term::Type(univ) =&gt; Value::Type(univ)
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>    // Lambda Evaluation: Constructs a closure capturing the environment and parameter.
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>    case Term::Lambda(paramIdent, paramTypeTerm, bodyTerm) =&gt; {
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a>            // Evaluate the body with the argument bound.
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>            env.add(paramIdent, arg, paramType).evaluate(bodyTerm)
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>        }
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>        Value::Lambda(paramType, closure)
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a>    }
</span><span id="__span-4-15"><a id="__codelineno-4-15" name="__codelineno-4-15" href="#__codelineno-4-15"></a>    // Pi Type Evaluation: Similar to lambda
</span><span id="__span-4-16"><a id="__codelineno-4-16" name="__codelineno-4-16" href="#__codelineno-4-16"></a>    case Term::Pi(paramIdent, paramTypeTerm, codomainTerm) =&gt; {
</span><span id="__span-4-17"><a id="__codelineno-4-17" name="__codelineno-4-17" href="#__codelineno-4-17"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-4-18"><a id="__codelineno-4-18" name="__codelineno-4-18" href="#__codelineno-4-18"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-4-19"><a id="__codelineno-4-19" name="__codelineno-4-19" href="#__codelineno-4-19"></a>            // Evaluate codomain with argument bound.
</span><span id="__span-4-20"><a id="__codelineno-4-20" name="__codelineno-4-20" href="#__codelineno-4-20"></a>            env.add(paramIdent, arg, paramType).evaluate(codomainTerm)
</span><span id="__span-4-21"><a id="__codelineno-4-21" name="__codelineno-4-21" href="#__codelineno-4-21"></a>        }
</span><span id="__span-4-22"><a id="__codelineno-4-22" name="__codelineno-4-22" href="#__codelineno-4-22"></a>        Value::Pi(paramType, closure)
</span><span id="__span-4-23"><a id="__codelineno-4-23" name="__codelineno-4-23" href="#__codelineno-4-23"></a>    }
</span><span id="__span-4-24"><a id="__codelineno-4-24" name="__codelineno-4-24" href="#__codelineno-4-24"></a>    // Sigma Type Evaluation: Similar to lambda
</span><span id="__span-4-25"><a id="__codelineno-4-25" name="__codelineno-4-25" href="#__codelineno-4-25"></a>    case Term::Sigma(paramIdent, paramTypeTerm, codomainTerm) =&gt; {
</span><span id="__span-4-26"><a id="__codelineno-4-26" name="__codelineno-4-26" href="#__codelineno-4-26"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-4-27"><a id="__codelineno-4-27" name="__codelineno-4-27" href="#__codelineno-4-27"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-4-28"><a id="__codelineno-4-28" name="__codelineno-4-28" href="#__codelineno-4-28"></a>            // Evaluate codomain with argument bound.
</span><span id="__span-4-29"><a id="__codelineno-4-29" name="__codelineno-4-29" href="#__codelineno-4-29"></a>            env.add(paramIdent, arg, paramType).evaluate(codomainTerm)
</span><span id="__span-4-30"><a id="__codelineno-4-30" name="__codelineno-4-30" href="#__codelineno-4-30"></a>        }
</span><span id="__span-4-31"><a id="__codelineno-4-31" name="__codelineno-4-31" href="#__codelineno-4-31"></a>        Value::Sigma(paramType, closure)
</span><span id="__span-4-32"><a id="__codelineno-4-32" name="__codelineno-4-32" href="#__codelineno-4-32"></a>    }
</span><span id="__span-4-33"><a id="__codelineno-4-33" name="__codelineno-4-33" href="#__codelineno-4-33"></a>    // Function Application Evaluation
</span><span id="__span-4-34"><a id="__codelineno-4-34" name="__codelineno-4-34" href="#__codelineno-4-34"></a>    case Term::Apply(fn, arg) =&gt; match env.evaluate(fn) {
</span><span id="__span-4-35"><a id="__codelineno-4-35" name="__codelineno-4-35" href="#__codelineno-4-35"></a>        // Apply function to the argument.
</span><span id="__span-4-36"><a id="__codelineno-4-36" name="__codelineno-4-36" href="#__codelineno-4-36"></a>        case Value::Lambda(_, fn) =&gt; fn(env.evaluate(arg))
</span><span id="__span-4-37"><a id="__codelineno-4-37" name="__codelineno-4-37" href="#__codelineno-4-37"></a>        // Neutral Application: Cannot reduce further; keep it a neutral value.
</span><span id="__span-4-38"><a id="__codelineno-4-38" name="__codelineno-4-38" href="#__codelineno-4-38"></a>        case Value::Neutral(neutral) =&gt; NeutralValue::Apply(neutral, env.evaluate(arg)).toValue
</span><span id="__span-4-39"><a id="__codelineno-4-39" name="__codelineno-4-39" href="#__codelineno-4-39"></a>        case _ =&gt; panic(&quot;Invalid type: not a function&quot;)
</span><span id="__span-4-40"><a id="__codelineno-4-40" name="__codelineno-4-40" href="#__codelineno-4-40"></a>    }
</span><span id="__span-4-41"><a id="__codelineno-4-41" name="__codelineno-4-41" href="#__codelineno-4-41"></a>    // Pair Construction
</span><span id="__span-4-42"><a id="__codelineno-4-42" name="__codelineno-4-42" href="#__codelineno-4-42"></a>    case Term::Pair(fst, snd) =&gt; Value::Pair(env.evaluate(fst), env.evaluate(snd))
</span><span id="__span-4-43"><a id="__codelineno-4-43" name="__codelineno-4-43" href="#__codelineno-4-43"></a>}
</span></code></pre></div>
</div>

<h3 id="reification-read-back">Reification (Read-Back)</h3>
<p>The final stage in NBE is reification, which converts evaluated values back into syntactic terms, producing a term in its normal form. Reification ensures that the term representation is irreducible and allows comparisons of normalized terms. In essence, reification “reads back” a value by converting closures and neutral values to their term equivalents. For example:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>def readBack(value: Value, env: Env): Term = match value {
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>    case Value::Neutral(neutral) =&gt; neutral.readBack(env)
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>    case Value::Type(univ) =&gt; Term::Type(univ)
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>    case Value::Pair(fst, snd) =&gt; Term::Pair(fst.readBack(env), snd.readBack(env))
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>    // Lambda Normalization: Generate a fresh variable to avoid capture.
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>    case Value::Lambda(paramType, fn) =&gt; {
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a>        // Normalize parameter type.
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-5-11"><a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a>        // Create variable value.
</span><span id="__span-5-12"><a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-5-13"><a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a>        // Extend environment.
</span><span id="__span-5-14"><a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-5-15"><a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a>        Term::Lambda(
</span><span id="__span-5-16"><a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a>            paramIdent, paramTypeTerm,         // Construct lambda term.
</span><span id="__span-5-17"><a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a>            fn(variable).readBack(updatedEnv)  // Normalize the body.
</span><span id="__span-5-18"><a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a>        )
</span><span id="__span-5-19"><a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a>    }
</span><span id="__span-5-20"><a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a>
</span><span id="__span-5-21"><a id="__codelineno-5-21" name="__codelineno-5-21" href="#__codelineno-5-21"></a>    // Pi Type Normalization: Similar to lambda normalization.
</span><span id="__span-5-22"><a id="__codelineno-5-22" name="__codelineno-5-22" href="#__codelineno-5-22"></a>    case Value::Pi(paramType, fn) =&gt; {
</span><span id="__span-5-23"><a id="__codelineno-5-23" name="__codelineno-5-23" href="#__codelineno-5-23"></a>        // Fresh parameter name.
</span><span id="__span-5-24"><a id="__codelineno-5-24" name="__codelineno-5-24" href="#__codelineno-5-24"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-5-25"><a id="__codelineno-5-25" name="__codelineno-5-25" href="#__codelineno-5-25"></a>        // Normalize parameter type.
</span><span id="__span-5-26"><a id="__codelineno-5-26" name="__codelineno-5-26" href="#__codelineno-5-26"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-5-27"><a id="__codelineno-5-27" name="__codelineno-5-27" href="#__codelineno-5-27"></a>        // Create variable value.
</span><span id="__span-5-28"><a id="__codelineno-5-28" name="__codelineno-5-28" href="#__codelineno-5-28"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-5-29"><a id="__codelineno-5-29" name="__codelineno-5-29" href="#__codelineno-5-29"></a>        // Extend environment.
</span><span id="__span-5-30"><a id="__codelineno-5-30" name="__codelineno-5-30" href="#__codelineno-5-30"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-5-31"><a id="__codelineno-5-31" name="__codelineno-5-31" href="#__codelineno-5-31"></a>        Term::Pi(
</span><span id="__span-5-32"><a id="__codelineno-5-32" name="__codelineno-5-32" href="#__codelineno-5-32"></a>            paramIdent, paramTypeTerm,          // Construct Pi type term.
</span><span id="__span-5-33"><a id="__codelineno-5-33" name="__codelineno-5-33" href="#__codelineno-5-33"></a>            fn(variable).readBack(updatedEnv)   // Normalize the codomain.
</span><span id="__span-5-34"><a id="__codelineno-5-34" name="__codelineno-5-34" href="#__codelineno-5-34"></a>        )
</span><span id="__span-5-35"><a id="__codelineno-5-35" name="__codelineno-5-35" href="#__codelineno-5-35"></a>    }
</span><span id="__span-5-36"><a id="__codelineno-5-36" name="__codelineno-5-36" href="#__codelineno-5-36"></a>
</span><span id="__span-5-37"><a id="__codelineno-5-37" name="__codelineno-5-37" href="#__codelineno-5-37"></a>    // Sigma Type Normalization: Similar to lambda normalization.
</span><span id="__span-5-38"><a id="__codelineno-5-38" name="__codelineno-5-38" href="#__codelineno-5-38"></a>    case Value::Sigma(paramType, fn) =&gt; {
</span><span id="__span-5-39"><a id="__codelineno-5-39" name="__codelineno-5-39" href="#__codelineno-5-39"></a>        // Fresh parameter name.
</span><span id="__span-5-40"><a id="__codelineno-5-40" name="__codelineno-5-40" href="#__codelineno-5-40"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-5-41"><a id="__codelineno-5-41" name="__codelineno-5-41" href="#__codelineno-5-41"></a>        // Normalize parameter type.
</span><span id="__span-5-42"><a id="__codelineno-5-42" name="__codelineno-5-42" href="#__codelineno-5-42"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-5-43"><a id="__codelineno-5-43" name="__codelineno-5-43" href="#__codelineno-5-43"></a>        // Create variable value.
</span><span id="__span-5-44"><a id="__codelineno-5-44" name="__codelineno-5-44" href="#__codelineno-5-44"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-5-45"><a id="__codelineno-5-45" name="__codelineno-5-45" href="#__codelineno-5-45"></a>        // Extend environment.
</span><span id="__span-5-46"><a id="__codelineno-5-46" name="__codelineno-5-46" href="#__codelineno-5-46"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-5-47"><a id="__codelineno-5-47" name="__codelineno-5-47" href="#__codelineno-5-47"></a>        Term::Sigma(
</span><span id="__span-5-48"><a id="__codelineno-5-48" name="__codelineno-5-48" href="#__codelineno-5-48"></a>            paramIdent, paramTypeTerm,          // Construct Sigma type term.
</span><span id="__span-5-49"><a id="__codelineno-5-49" name="__codelineno-5-49" href="#__codelineno-5-49"></a>            fn(variable).readBack(updatedEnv)   // Normalize the codomain.
</span><span id="__span-5-50"><a id="__codelineno-5-50" name="__codelineno-5-50" href="#__codelineno-5-50"></a>        )
</span><span id="__span-5-51"><a id="__codelineno-5-51" name="__codelineno-5-51" href="#__codelineno-5-51"></a>    }
</span><span id="__span-5-52"><a id="__codelineno-5-52" name="__codelineno-5-52" href="#__codelineno-5-52"></a>}
</span></code></pre></div>
</div>

<h3 id="neutral-value-reification">Neutral Value Reification</h3>
<p>Neutral terms are read back by preserving the unresolved structure, which makes them appear in their simplest, irreducible forms. For instance, if the neutral term is a variable <code>x</code>, <code>readBack</code> simply returns <code>Term::Var(x)</code>:</p>
<div class="code-editor">

<div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>def readBack(neutral: NeutralValue, env: Env): Term = match neutral {
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>    // Convert variable to term.
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>    case NeutralValue::Var(name) =&gt; Term::Var(name)
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>    // Reconstruct application.
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a>    case NeutralValue::Apply(fn, arg) =&gt; Term::Apply(fn.readBack(env), arg.readBack(env))
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a>    // Reconstruct projection.
</span><span id="__span-6-7"><a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a>    case NeutralValue::Proj(proj, neutral) =&gt; Term::Proj(proj, neutral.readBack(env))
</span><span id="__span-6-8"><a id="__codelineno-6-8" name="__codelineno-6-8" href="#__codelineno-6-8"></a>}
</span></code></pre></div>
</div>

<h3 id="formalization-of-nbes-core-operations">Formalization of NBE’s Core Operations</h3>
<p>In formal terms, NBE employs structured definitions of evaluation and application, capturing both the computational essence and logical foundation of dependent type theories. These formalizations are represented with mathematical notations:</p>
<h4 id="evaluation-rules">Evaluation Rules</h4>
<div class="arithmatex">\[
⟦ x ⟧_{\rho} = \rho(x)
\]</div>
<p>For a variable <span class="arithmatex">\(x\)</span>, evaluation retrieves <span class="arithmatex">\(x\)</span>'s value from the environment <span class="arithmatex">\(\rho\)</span>.</p>
<div class="arithmatex">\[
⟦ \lambda x.t ⟧_{\rho} = (\rho, \lambda x.t)
\]</div>
<p>A lambda function evaluates to a closure with <span class="arithmatex">\(\rho\)</span> capturing the environment.</p>
<div class="arithmatex">\[
⟦ t \ u ⟧_{\rho} = ⟦ t ⟧_{\rho} \cdot ⟦ u ⟧_{\rho}
\]</div>
<p>Application proceeds by evaluating both the function <span class="arithmatex">\(t\)</span> and argument <span class="arithmatex">\(u\)</span>.</p>
<h4 id="application-in-formal-terms">Application in Formal Terms</h4>
<p>Application between values distinguishes between closures and neutral values:</p>
<p>$$
(\rho, \lambda x.t) \cdot v = ⟦ t ⟧_{\rho[x \mapsto v]}
$$
If the function is a closure, the argument <span class="arithmatex">\(v\)</span> extends the environment.</p>
<p>$$
n \cdot v = \text{Neutral}(n \ v)
$$
For neutral values, application produces another neutral structure.</p>
<h2 id="complete-implementation">Complete Implementation</h2>
<p>The following code implements a simple type checker and evaluator for Martin-Löf Type Theory (MLTT).</p>
<div class="code-editor" id="code-mltt">

<div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>/**
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a> * This code implements a simple type checker and evaluator for Martin-Löf Type Theory (MLTT).
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a> *
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a> * MLTT is a constructive type theory foundational to many proof assistants and dependently
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a> * typed programming languages, such as Agda (MLTT) and Coq (CIC).
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a> *
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a> * In MLTT, types depend on values, leading to a system where functions can accept types
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a> * as parameters and return types as results. Key concepts include:
</span><span id="__span-7-9"><a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a> * - Dependent Function Types (Pi Types): Generalizations of function types where the
</span><span id="__span-7-10"><a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a> *   return type depends on the input value.
</span><span id="__span-7-11"><a id="__codelineno-7-11" name="__codelineno-7-11" href="#__codelineno-7-11"></a> * - Lambda Abstractions: Anonymous functions defined by specifying parameters and body.
</span><span id="__span-7-12"><a id="__codelineno-7-12" name="__codelineno-7-12" href="#__codelineno-7-12"></a> * - Universes: A hierarchy of types (e.g., `Type(0)`, `Type(1)`, etc.).
</span><span id="__span-7-13"><a id="__codelineno-7-13" name="__codelineno-7-13" href="#__codelineno-7-13"></a> *
</span><span id="__span-7-14"><a id="__codelineno-7-14" name="__codelineno-7-14" href="#__codelineno-7-14"></a> * This implementation models core constructs of MLTT, including terms, values, environments,
</span><span id="__span-7-15"><a id="__codelineno-7-15" name="__codelineno-7-15" href="#__codelineno-7-15"></a> * evaluation, type inference, and normalization.
</span><span id="__span-7-16"><a id="__codelineno-7-16" name="__codelineno-7-16" href="#__codelineno-7-16"></a> */
</span><span id="__span-7-17"><a id="__codelineno-7-17" name="__codelineno-7-17" href="#__codelineno-7-17"></a>
</span><span id="__span-7-18"><a id="__codelineno-7-18" name="__codelineno-7-18" href="#__codelineno-7-18"></a>/**
</span><span id="__span-7-19"><a id="__codelineno-7-19" name="__codelineno-7-19" href="#__codelineno-7-19"></a> * Extracts the value from an `Option[A]`. Throws an error if the option is `None`.
</span><span id="__span-7-20"><a id="__codelineno-7-20" name="__codelineno-7-20" href="#__codelineno-7-20"></a> * @param &lt;A&gt; Type of the value.
</span><span id="__span-7-21"><a id="__codelineno-7-21" name="__codelineno-7-21" href="#__codelineno-7-21"></a> * @param option The `Option` instance.
</span><span id="__span-7-22"><a id="__codelineno-7-22" name="__codelineno-7-22" href="#__codelineno-7-22"></a> * @return The extracted value of type `A`.
</span><span id="__span-7-23"><a id="__codelineno-7-23" name="__codelineno-7-23" href="#__codelineno-7-23"></a> */
</span><span id="__span-7-24"><a id="__codelineno-7-24" name="__codelineno-7-24" href="#__codelineno-7-24"></a>type Option[A: &#39;Type] = inductive {
</span><span id="__span-7-25"><a id="__codelineno-7-25" name="__codelineno-7-25" href="#__codelineno-7-25"></a>    None        // Represents the absence of a value.
</span><span id="__span-7-26"><a id="__codelineno-7-26" name="__codelineno-7-26" href="#__codelineno-7-26"></a>    Some(A)     // Wraps a value of type A.
</span><span id="__span-7-27"><a id="__codelineno-7-27" name="__codelineno-7-27" href="#__codelineno-7-27"></a>}
</span><span id="__span-7-28"><a id="__codelineno-7-28" name="__codelineno-7-28" href="#__codelineno-7-28"></a>
</span><span id="__span-7-29"><a id="__codelineno-7-29" name="__codelineno-7-29" href="#__codelineno-7-29"></a>/**
</span><span id="__span-7-30"><a id="__codelineno-7-30" name="__codelineno-7-30" href="#__codelineno-7-30"></a> * Extracts the value from an `Option[A]`. Throws an error if the option is `None`.
</span><span id="__span-7-31"><a id="__codelineno-7-31" name="__codelineno-7-31" href="#__codelineno-7-31"></a> * @param &lt;A&gt; Type of the value.
</span><span id="__span-7-32"><a id="__codelineno-7-32" name="__codelineno-7-32" href="#__codelineno-7-32"></a> * @param option The `Option` instance.
</span><span id="__span-7-33"><a id="__codelineno-7-33" name="__codelineno-7-33" href="#__codelineno-7-33"></a> * @return The extracted value of type `A`.
</span><span id="__span-7-34"><a id="__codelineno-7-34" name="__codelineno-7-34" href="#__codelineno-7-34"></a> */
</span><span id="__span-7-35"><a id="__codelineno-7-35" name="__codelineno-7-35" href="#__codelineno-7-35"></a>def unwrap[A: &#39;Type](option: Option[A]): A = match option {
</span><span id="__span-7-36"><a id="__codelineno-7-36" name="__codelineno-7-36" href="#__codelineno-7-36"></a>    case Option[A]::None =&gt; panic(&quot;Unwrapping a none option type&quot;)
</span><span id="__span-7-37"><a id="__codelineno-7-37" name="__codelineno-7-37" href="#__codelineno-7-37"></a>    case Option[A]::Some(value) =&gt; value
</span><span id="__span-7-38"><a id="__codelineno-7-38" name="__codelineno-7-38" href="#__codelineno-7-38"></a>}
</span><span id="__span-7-39"><a id="__codelineno-7-39" name="__codelineno-7-39" href="#__codelineno-7-39"></a>
</span><span id="__span-7-40"><a id="__codelineno-7-40" name="__codelineno-7-40" href="#__codelineno-7-40"></a>/**
</span><span id="__span-7-41"><a id="__codelineno-7-41" name="__codelineno-7-41" href="#__codelineno-7-41"></a> * `Term` represents the syntax of expressions in MLTT. Each constructor corresponds
</span><span id="__span-7-42"><a id="__codelineno-7-42" name="__codelineno-7-42" href="#__codelineno-7-42"></a> * to a syntactic category.
</span><span id="__span-7-43"><a id="__codelineno-7-43" name="__codelineno-7-43" href="#__codelineno-7-43"></a> */
</span><span id="__span-7-44"><a id="__codelineno-7-44" name="__codelineno-7-44" href="#__codelineno-7-44"></a>type Term = inductive {
</span><span id="__span-7-45"><a id="__codelineno-7-45" name="__codelineno-7-45" href="#__codelineno-7-45"></a>    // Variable: Represents a variable identified by its name.
</span><span id="__span-7-46"><a id="__codelineno-7-46" name="__codelineno-7-46" href="#__codelineno-7-46"></a>    Var(String)
</span><span id="__span-7-47"><a id="__codelineno-7-47" name="__codelineno-7-47" href="#__codelineno-7-47"></a>    // Universe Level: Represents types at a certain universe level.
</span><span id="__span-7-48"><a id="__codelineno-7-48" name="__codelineno-7-48" href="#__codelineno-7-48"></a>    Type(Int)
</span><span id="__span-7-49"><a id="__codelineno-7-49" name="__codelineno-7-49" href="#__codelineno-7-49"></a>    // Dependent Pi Type: `Π(x : A). B`, where `B` may depend on `x`.
</span><span id="__span-7-50"><a id="__codelineno-7-50" name="__codelineno-7-50" href="#__codelineno-7-50"></a>    Pi(String, Term, Term)
</span><span id="__span-7-51"><a id="__codelineno-7-51" name="__codelineno-7-51" href="#__codelineno-7-51"></a>    // Lambda Term: `λ(x : A). t`.
</span><span id="__span-7-52"><a id="__codelineno-7-52" name="__codelineno-7-52" href="#__codelineno-7-52"></a>    Lambda(String, Term, Term)
</span><span id="__span-7-53"><a id="__codelineno-7-53" name="__codelineno-7-53" href="#__codelineno-7-53"></a>    // Application: Applying a function to an argument.
</span><span id="__span-7-54"><a id="__codelineno-7-54" name="__codelineno-7-54" href="#__codelineno-7-54"></a>    Apply(Term, Term)
</span><span id="__span-7-55"><a id="__codelineno-7-55" name="__codelineno-7-55" href="#__codelineno-7-55"></a>    // Sigma Type: `Σ(x : A). B`, a dependent pair type.
</span><span id="__span-7-56"><a id="__codelineno-7-56" name="__codelineno-7-56" href="#__codelineno-7-56"></a>    Sigma(String, Term, Term)
</span><span id="__span-7-57"><a id="__codelineno-7-57" name="__codelineno-7-57" href="#__codelineno-7-57"></a>    // Pair Term: `(a, b)`.
</span><span id="__span-7-58"><a id="__codelineno-7-58" name="__codelineno-7-58" href="#__codelineno-7-58"></a>    Pair(Term, Term)
</span><span id="__span-7-59"><a id="__codelineno-7-59" name="__codelineno-7-59" href="#__codelineno-7-59"></a>    // Projection: Extracting the first or second element of a pair.
</span><span id="__span-7-60"><a id="__codelineno-7-60" name="__codelineno-7-60" href="#__codelineno-7-60"></a>    Proj(Projection, Term)
</span><span id="__span-7-61"><a id="__codelineno-7-61" name="__codelineno-7-61" href="#__codelineno-7-61"></a>}
</span><span id="__span-7-62"><a id="__codelineno-7-62" name="__codelineno-7-62" href="#__codelineno-7-62"></a>
</span><span id="__span-7-63"><a id="__codelineno-7-63" name="__codelineno-7-63" href="#__codelineno-7-63"></a>type Projection = inductive {
</span><span id="__span-7-64"><a id="__codelineno-7-64" name="__codelineno-7-64" href="#__codelineno-7-64"></a>    Fst; Snd
</span><span id="__span-7-65"><a id="__codelineno-7-65" name="__codelineno-7-65" href="#__codelineno-7-65"></a>}
</span><span id="__span-7-66"><a id="__codelineno-7-66" name="__codelineno-7-66" href="#__codelineno-7-66"></a>
</span><span id="__span-7-67"><a id="__codelineno-7-67" name="__codelineno-7-67" href="#__codelineno-7-67"></a>/**
</span><span id="__span-7-68"><a id="__codelineno-7-68" name="__codelineno-7-68" href="#__codelineno-7-68"></a> * `Value` represents the evaluated form of terms, reducing to values during evaluation.
</span><span id="__span-7-69"><a id="__codelineno-7-69" name="__codelineno-7-69" href="#__codelineno-7-69"></a> */
</span><span id="__span-7-70"><a id="__codelineno-7-70" name="__codelineno-7-70" href="#__codelineno-7-70"></a>type Value = inductive {
</span><span id="__span-7-71"><a id="__codelineno-7-71" name="__codelineno-7-71" href="#__codelineno-7-71"></a>    // Neutral Value: A value that cannot be reduced further
</span><span id="__span-7-72"><a id="__codelineno-7-72" name="__codelineno-7-72" href="#__codelineno-7-72"></a>    Neutral(NeutralValue)
</span><span id="__span-7-73"><a id="__codelineno-7-73" name="__codelineno-7-73" href="#__codelineno-7-73"></a>    // Universe Level: A type at a specific universe level.
</span><span id="__span-7-74"><a id="__codelineno-7-74" name="__codelineno-7-74" href="#__codelineno-7-74"></a>    Type(Int)
</span><span id="__span-7-75"><a id="__codelineno-7-75" name="__codelineno-7-75" href="#__codelineno-7-75"></a>    // Lambda Function: A function value with its parameter type and body.
</span><span id="__span-7-76"><a id="__codelineno-7-76" name="__codelineno-7-76" href="#__codelineno-7-76"></a>    Lambda(Value, Value -&gt; Value)
</span><span id="__span-7-77"><a id="__codelineno-7-77" name="__codelineno-7-77" href="#__codelineno-7-77"></a>    // Pi Type Value: Represents a dependent function type.
</span><span id="__span-7-78"><a id="__codelineno-7-78" name="__codelineno-7-78" href="#__codelineno-7-78"></a>    Pi(Value, Value -&gt; Value)
</span><span id="__span-7-79"><a id="__codelineno-7-79" name="__codelineno-7-79" href="#__codelineno-7-79"></a>    // Sigma Type Value: Represents a dependent pair type.
</span><span id="__span-7-80"><a id="__codelineno-7-80" name="__codelineno-7-80" href="#__codelineno-7-80"></a>    Sigma(Value, Value -&gt; Value)
</span><span id="__span-7-81"><a id="__codelineno-7-81" name="__codelineno-7-81" href="#__codelineno-7-81"></a>    // Pair Value: A pair of values.
</span><span id="__span-7-82"><a id="__codelineno-7-82" name="__codelineno-7-82" href="#__codelineno-7-82"></a>    Pair(Value, Value)
</span><span id="__span-7-83"><a id="__codelineno-7-83" name="__codelineno-7-83" href="#__codelineno-7-83"></a>}
</span><span id="__span-7-84"><a id="__codelineno-7-84" name="__codelineno-7-84" href="#__codelineno-7-84"></a>
</span><span id="__span-7-85"><a id="__codelineno-7-85" name="__codelineno-7-85" href="#__codelineno-7-85"></a>/**
</span><span id="__span-7-86"><a id="__codelineno-7-86" name="__codelineno-7-86" href="#__codelineno-7-86"></a> * Types are represented as values within this implementation.
</span><span id="__span-7-87"><a id="__codelineno-7-87" name="__codelineno-7-87" href="#__codelineno-7-87"></a> */
</span><span id="__span-7-88"><a id="__codelineno-7-88" name="__codelineno-7-88" href="#__codelineno-7-88"></a>type Type = Value
</span><span id="__span-7-89"><a id="__codelineno-7-89" name="__codelineno-7-89" href="#__codelineno-7-89"></a>
</span><span id="__span-7-90"><a id="__codelineno-7-90" name="__codelineno-7-90" href="#__codelineno-7-90"></a>// **Neutral Values**
</span><span id="__span-7-91"><a id="__codelineno-7-91" name="__codelineno-7-91" href="#__codelineno-7-91"></a>
</span><span id="__span-7-92"><a id="__codelineno-7-92" name="__codelineno-7-92" href="#__codelineno-7-92"></a>/*
</span><span id="__span-7-93"><a id="__codelineno-7-93" name="__codelineno-7-93" href="#__codelineno-7-93"></a> * `NeutralValue` represents expressions that cannot be evaluated further due to
</span><span id="__span-7-94"><a id="__codelineno-7-94" name="__codelineno-7-94" href="#__codelineno-7-94"></a> * the absence of sufficient information (e.g., variables or applications of variables).
</span><span id="__span-7-95"><a id="__codelineno-7-95" name="__codelineno-7-95" href="#__codelineno-7-95"></a> */
</span><span id="__span-7-96"><a id="__codelineno-7-96" name="__codelineno-7-96" href="#__codelineno-7-96"></a>type NeutralValue = inductive {
</span><span id="__span-7-97"><a id="__codelineno-7-97" name="__codelineno-7-97" href="#__codelineno-7-97"></a>    // Variable: A neutral value representing an unresolved variable.
</span><span id="__span-7-98"><a id="__codelineno-7-98" name="__codelineno-7-98" href="#__codelineno-7-98"></a>    Var(String)
</span><span id="__span-7-99"><a id="__codelineno-7-99" name="__codelineno-7-99" href="#__codelineno-7-99"></a>    // Application: Applying a neutral function to a value.
</span><span id="__span-7-100"><a id="__codelineno-7-100" name="__codelineno-7-100" href="#__codelineno-7-100"></a>    Apply(NeutralValue, Value)
</span><span id="__span-7-101"><a id="__codelineno-7-101" name="__codelineno-7-101" href="#__codelineno-7-101"></a>    // Projection: Extracting the first or second element of a pair.
</span><span id="__span-7-102"><a id="__codelineno-7-102" name="__codelineno-7-102" href="#__codelineno-7-102"></a>    Proj(Projection, NeutralValue)
</span><span id="__span-7-103"><a id="__codelineno-7-103" name="__codelineno-7-103" href="#__codelineno-7-103"></a>}
</span><span id="__span-7-104"><a id="__codelineno-7-104" name="__codelineno-7-104" href="#__codelineno-7-104"></a>
</span><span id="__span-7-105"><a id="__codelineno-7-105" name="__codelineno-7-105" href="#__codelineno-7-105"></a>/**
</span><span id="__span-7-106"><a id="__codelineno-7-106" name="__codelineno-7-106" href="#__codelineno-7-106"></a> * Converts a `NeutralValue` into a `Value`.
</span><span id="__span-7-107"><a id="__codelineno-7-107" name="__codelineno-7-107" href="#__codelineno-7-107"></a> * @param neutral The `NeutralValue` to convert.
</span><span id="__span-7-108"><a id="__codelineno-7-108" name="__codelineno-7-108" href="#__codelineno-7-108"></a> * @return The resulting `Value`.
</span><span id="__span-7-109"><a id="__codelineno-7-109" name="__codelineno-7-109" href="#__codelineno-7-109"></a> */
</span><span id="__span-7-110"><a id="__codelineno-7-110" name="__codelineno-7-110" href="#__codelineno-7-110"></a>def toValue(neutral: NeutralValue): Value = Value::Neutral(neutral)
</span><span id="__span-7-111"><a id="__codelineno-7-111" name="__codelineno-7-111" href="#__codelineno-7-111"></a>
</span><span id="__span-7-112"><a id="__codelineno-7-112" name="__codelineno-7-112" href="#__codelineno-7-112"></a>/**
</span><span id="__span-7-113"><a id="__codelineno-7-113" name="__codelineno-7-113" href="#__codelineno-7-113"></a> * `TypedValue` pairs a value with its type, essential for type checking and
</span><span id="__span-7-114"><a id="__codelineno-7-114" name="__codelineno-7-114" href="#__codelineno-7-114"></a> * ensuring type safety during evaluation.
</span><span id="__span-7-115"><a id="__codelineno-7-115" name="__codelineno-7-115" href="#__codelineno-7-115"></a> */
</span><span id="__span-7-116"><a id="__codelineno-7-116" name="__codelineno-7-116" href="#__codelineno-7-116"></a>type TypedValue = record {
</span><span id="__span-7-117"><a id="__codelineno-7-117" name="__codelineno-7-117" href="#__codelineno-7-117"></a>    value: Value    // The evaluated value.
</span><span id="__span-7-118"><a id="__codelineno-7-118" name="__codelineno-7-118" href="#__codelineno-7-118"></a>    ty: Type        // The type of the value.
</span><span id="__span-7-119"><a id="__codelineno-7-119" name="__codelineno-7-119" href="#__codelineno-7-119"></a>}
</span><span id="__span-7-120"><a id="__codelineno-7-120" name="__codelineno-7-120" href="#__codelineno-7-120"></a>
</span><span id="__span-7-121"><a id="__codelineno-7-121" name="__codelineno-7-121" href="#__codelineno-7-121"></a>/**
</span><span id="__span-7-122"><a id="__codelineno-7-122" name="__codelineno-7-122" href="#__codelineno-7-122"></a> * `Env` represents the typing context, mapping variable names to their corresponding typed values.
</span><span id="__span-7-123"><a id="__codelineno-7-123" name="__codelineno-7-123" href="#__codelineno-7-123"></a> */
</span><span id="__span-7-124"><a id="__codelineno-7-124" name="__codelineno-7-124" href="#__codelineno-7-124"></a>type Env = inductive {
</span><span id="__span-7-125"><a id="__codelineno-7-125" name="__codelineno-7-125" href="#__codelineno-7-125"></a>    Empty
</span><span id="__span-7-126"><a id="__codelineno-7-126" name="__codelineno-7-126" href="#__codelineno-7-126"></a>    Cons(String, TypedValue, Env)
</span><span id="__span-7-127"><a id="__codelineno-7-127" name="__codelineno-7-127" href="#__codelineno-7-127"></a>}
</span><span id="__span-7-128"><a id="__codelineno-7-128" name="__codelineno-7-128" href="#__codelineno-7-128"></a>
</span><span id="__span-7-129"><a id="__codelineno-7-129" name="__codelineno-7-129" href="#__codelineno-7-129"></a>/**
</span><span id="__span-7-130"><a id="__codelineno-7-130" name="__codelineno-7-130" href="#__codelineno-7-130"></a> * Adds a new binding to the environment.
</span><span id="__span-7-131"><a id="__codelineno-7-131" name="__codelineno-7-131" href="#__codelineno-7-131"></a> * @param env The current environment.
</span><span id="__span-7-132"><a id="__codelineno-7-132" name="__codelineno-7-132" href="#__codelineno-7-132"></a> * @param name The variable name.
</span><span id="__span-7-133"><a id="__codelineno-7-133" name="__codelineno-7-133" href="#__codelineno-7-133"></a> * @param value The value to bind.
</span><span id="__span-7-134"><a id="__codelineno-7-134" name="__codelineno-7-134" href="#__codelineno-7-134"></a> * @param ty The type of the value.
</span><span id="__span-7-135"><a id="__codelineno-7-135" name="__codelineno-7-135" href="#__codelineno-7-135"></a> * @return A new environment with the added binding.
</span><span id="__span-7-136"><a id="__codelineno-7-136" name="__codelineno-7-136" href="#__codelineno-7-136"></a> */
</span><span id="__span-7-137"><a id="__codelineno-7-137" name="__codelineno-7-137" href="#__codelineno-7-137"></a>def add(env: Env, name: String, value: Value, ty: Type): Env = {
</span><span id="__span-7-138"><a id="__codelineno-7-138" name="__codelineno-7-138" href="#__codelineno-7-138"></a>    let typedValue = TypedValue &#39;{
</span><span id="__span-7-139"><a id="__codelineno-7-139" name="__codelineno-7-139" href="#__codelineno-7-139"></a>        value = value  // The value associated with the name.
</span><span id="__span-7-140"><a id="__codelineno-7-140" name="__codelineno-7-140" href="#__codelineno-7-140"></a>        ty = ty        // The type of the value.
</span><span id="__span-7-141"><a id="__codelineno-7-141" name="__codelineno-7-141" href="#__codelineno-7-141"></a>    }
</span><span id="__span-7-142"><a id="__codelineno-7-142" name="__codelineno-7-142" href="#__codelineno-7-142"></a>    Env::Cons(name, typedValue, env)
</span><span id="__span-7-143"><a id="__codelineno-7-143" name="__codelineno-7-143" href="#__codelineno-7-143"></a>}
</span><span id="__span-7-144"><a id="__codelineno-7-144" name="__codelineno-7-144" href="#__codelineno-7-144"></a>
</span><span id="__span-7-145"><a id="__codelineno-7-145" name="__codelineno-7-145" href="#__codelineno-7-145"></a>/**
</span><span id="__span-7-146"><a id="__codelineno-7-146" name="__codelineno-7-146" href="#__codelineno-7-146"></a> * Adds a variable to the environment as a neutral value, commonly used when introducing parameters.
</span><span id="__span-7-147"><a id="__codelineno-7-147" name="__codelineno-7-147" href="#__codelineno-7-147"></a> * @param env The current environment.
</span><span id="__span-7-148"><a id="__codelineno-7-148" name="__codelineno-7-148" href="#__codelineno-7-148"></a> * @param ident The identifier of the variable.
</span><span id="__span-7-149"><a id="__codelineno-7-149" name="__codelineno-7-149" href="#__codelineno-7-149"></a> * @param ty The type of the variable.
</span><span id="__span-7-150"><a id="__codelineno-7-150" name="__codelineno-7-150" href="#__codelineno-7-150"></a> * @return A new environment with the variable added as a neutral value.
</span><span id="__span-7-151"><a id="__codelineno-7-151" name="__codelineno-7-151" href="#__codelineno-7-151"></a> */
</span><span id="__span-7-152"><a id="__codelineno-7-152" name="__codelineno-7-152" href="#__codelineno-7-152"></a>def addVar(env: Env, ident: String, ty: Type): Env = {
</span><span id="__span-7-153"><a id="__codelineno-7-153" name="__codelineno-7-153" href="#__codelineno-7-153"></a>    env.add(ident, NeutralValue::Var(ident).toValue, ty)
</span><span id="__span-7-154"><a id="__codelineno-7-154" name="__codelineno-7-154" href="#__codelineno-7-154"></a>}
</span><span id="__span-7-155"><a id="__codelineno-7-155" name="__codelineno-7-155" href="#__codelineno-7-155"></a>
</span><span id="__span-7-156"><a id="__codelineno-7-156" name="__codelineno-7-156" href="#__codelineno-7-156"></a>/**
</span><span id="__span-7-157"><a id="__codelineno-7-157" name="__codelineno-7-157" href="#__codelineno-7-157"></a> * Retrieves a binding from the environment by name.
</span><span id="__span-7-158"><a id="__codelineno-7-158" name="__codelineno-7-158" href="#__codelineno-7-158"></a> * @param env The current environment.
</span><span id="__span-7-159"><a id="__codelineno-7-159" name="__codelineno-7-159" href="#__codelineno-7-159"></a> * @param name The name of the variable to retrieve.
</span><span id="__span-7-160"><a id="__codelineno-7-160" name="__codelineno-7-160" href="#__codelineno-7-160"></a> * @return An `Option` of `TypedValue` containing the variable&#39;s type if found, or `None` if not found.
</span><span id="__span-7-161"><a id="__codelineno-7-161" name="__codelineno-7-161" href="#__codelineno-7-161"></a> */
</span><span id="__span-7-162"><a id="__codelineno-7-162" name="__codelineno-7-162" href="#__codelineno-7-162"></a>def get(env: Env, name: String): Option[TypedValue] = {
</span><span id="__span-7-163"><a id="__codelineno-7-163" name="__codelineno-7-163" href="#__codelineno-7-163"></a>    match env {
</span><span id="__span-7-164"><a id="__codelineno-7-164" name="__codelineno-7-164" href="#__codelineno-7-164"></a>        case Env::Empty =&gt; Option[TypedValue]::None  // Name not found.
</span><span id="__span-7-165"><a id="__codelineno-7-165" name="__codelineno-7-165" href="#__codelineno-7-165"></a>        case Env::Cons(name&#39;, value, env&#39;) =&gt; {
</span><span id="__span-7-166"><a id="__codelineno-7-166" name="__codelineno-7-166" href="#__codelineno-7-166"></a>            if name&#39; == name then Option[TypedValue]::Some(value)
</span><span id="__span-7-167"><a id="__codelineno-7-167" name="__codelineno-7-167" href="#__codelineno-7-167"></a>            else env&#39;.get(name) // Search in the rest of the environment.
</span><span id="__span-7-168"><a id="__codelineno-7-168" name="__codelineno-7-168" href="#__codelineno-7-168"></a>        }
</span><span id="__span-7-169"><a id="__codelineno-7-169" name="__codelineno-7-169" href="#__codelineno-7-169"></a>    }
</span><span id="__span-7-170"><a id="__codelineno-7-170" name="__codelineno-7-170" href="#__codelineno-7-170"></a>}
</span><span id="__span-7-171"><a id="__codelineno-7-171" name="__codelineno-7-171" href="#__codelineno-7-171"></a>
</span><span id="__span-7-172"><a id="__codelineno-7-172" name="__codelineno-7-172" href="#__codelineno-7-172"></a>/**
</span><span id="__span-7-173"><a id="__codelineno-7-173" name="__codelineno-7-173" href="#__codelineno-7-173"></a> * Checks if a name exists in the environment.
</span><span id="__span-7-174"><a id="__codelineno-7-174" name="__codelineno-7-174" href="#__codelineno-7-174"></a> * @param env The current environment.
</span><span id="__span-7-175"><a id="__codelineno-7-175" name="__codelineno-7-175" href="#__codelineno-7-175"></a> * @param name The name to check for.
</span><span id="__span-7-176"><a id="__codelineno-7-176" name="__codelineno-7-176" href="#__codelineno-7-176"></a> * @return `true` if the name exists in the environment, `false` otherwise.
</span><span id="__span-7-177"><a id="__codelineno-7-177" name="__codelineno-7-177" href="#__codelineno-7-177"></a> */
</span><span id="__span-7-178"><a id="__codelineno-7-178" name="__codelineno-7-178" href="#__codelineno-7-178"></a>def contains(env: Env, name: String): Bool = match env {
</span><span id="__span-7-179"><a id="__codelineno-7-179" name="__codelineno-7-179" href="#__codelineno-7-179"></a>    case Env::Empty =&gt; false  // Name not found.
</span><span id="__span-7-180"><a id="__codelineno-7-180" name="__codelineno-7-180" href="#__codelineno-7-180"></a>    case Env::Cons(name&#39;, _, env&#39;) =&gt; name&#39; == name || env&#39;.contains(name)  // Found or continue searching.
</span><span id="__span-7-181"><a id="__codelineno-7-181" name="__codelineno-7-181" href="#__codelineno-7-181"></a>}
</span><span id="__span-7-182"><a id="__codelineno-7-182" name="__codelineno-7-182" href="#__codelineno-7-182"></a>
</span><span id="__span-7-183"><a id="__codelineno-7-183" name="__codelineno-7-183" href="#__codelineno-7-183"></a>/**
</span><span id="__span-7-184"><a id="__codelineno-7-184" name="__codelineno-7-184" href="#__codelineno-7-184"></a> * Generates a fresh identifier not present in the environment, used to avoid variable capture during substitution.
</span><span id="__span-7-185"><a id="__codelineno-7-185" name="__codelineno-7-185" href="#__codelineno-7-185"></a> * @param env The current environment.
</span><span id="__span-7-186"><a id="__codelineno-7-186" name="__codelineno-7-186" href="#__codelineno-7-186"></a> * @param cnt The starting count for generating identifiers.
</span><span id="__span-7-187"><a id="__codelineno-7-187" name="__codelineno-7-187" href="#__codelineno-7-187"></a> * @return A fresh identifier not currently in the environment.
</span><span id="__span-7-188"><a id="__codelineno-7-188" name="__codelineno-7-188" href="#__codelineno-7-188"></a> */
</span><span id="__span-7-189"><a id="__codelineno-7-189" name="__codelineno-7-189" href="#__codelineno-7-189"></a>def freshIdentFrom(env: Env, cnt: Int): String = {
</span><span id="__span-7-190"><a id="__codelineno-7-190" name="__codelineno-7-190" href="#__codelineno-7-190"></a>    let ident = &quot;$&quot; ++ cnt.toString     // Generates identifiers like `$0`, `$1`, etc.
</span><span id="__span-7-191"><a id="__codelineno-7-191" name="__codelineno-7-191" href="#__codelineno-7-191"></a>    if !env.contains(ident) then ident  // If not in the environment, it&#39;s fresh.
</span><span id="__span-7-192"><a id="__codelineno-7-192" name="__codelineno-7-192" href="#__codelineno-7-192"></a>    else env.freshIdentFrom(cnt + 1)    // Try the next identifier.
</span><span id="__span-7-193"><a id="__codelineno-7-193" name="__codelineno-7-193" href="#__codelineno-7-193"></a>}
</span><span id="__span-7-194"><a id="__codelineno-7-194" name="__codelineno-7-194" href="#__codelineno-7-194"></a>
</span><span id="__span-7-195"><a id="__codelineno-7-195" name="__codelineno-7-195" href="#__codelineno-7-195"></a>/**
</span><span id="__span-7-196"><a id="__codelineno-7-196" name="__codelineno-7-196" href="#__codelineno-7-196"></a> * Generates a fresh identifier starting from `$0`.
</span><span id="__span-7-197"><a id="__codelineno-7-197" name="__codelineno-7-197" href="#__codelineno-7-197"></a> * @param env The current environment.
</span><span id="__span-7-198"><a id="__codelineno-7-198" name="__codelineno-7-198" href="#__codelineno-7-198"></a> * @return A fresh identifier.
</span><span id="__span-7-199"><a id="__codelineno-7-199" name="__codelineno-7-199" href="#__codelineno-7-199"></a> */
</span><span id="__span-7-200"><a id="__codelineno-7-200" name="__codelineno-7-200" href="#__codelineno-7-200"></a>def freshIdent(env: Env): String = env.freshIdentFrom(0)
</span><span id="__span-7-201"><a id="__codelineno-7-201" name="__codelineno-7-201" href="#__codelineno-7-201"></a>
</span><span id="__span-7-202"><a id="__codelineno-7-202" name="__codelineno-7-202" href="#__codelineno-7-202"></a>/**
</span><span id="__span-7-203"><a id="__codelineno-7-203" name="__codelineno-7-203" href="#__codelineno-7-203"></a> * Evaluates a `Term` in a given environment to produce a `Value`.
</span><span id="__span-7-204"><a id="__codelineno-7-204" name="__codelineno-7-204" href="#__codelineno-7-204"></a> * Evaluation proceeds by pattern matching on the term&#39;s structure.
</span><span id="__span-7-205"><a id="__codelineno-7-205" name="__codelineno-7-205" href="#__codelineno-7-205"></a> * @param env The current environment.
</span><span id="__span-7-206"><a id="__codelineno-7-206" name="__codelineno-7-206" href="#__codelineno-7-206"></a> * @param expr The `Term` to evaluate.
</span><span id="__span-7-207"><a id="__codelineno-7-207" name="__codelineno-7-207" href="#__codelineno-7-207"></a> * @return The evaluated `Value`.
</span><span id="__span-7-208"><a id="__codelineno-7-208" name="__codelineno-7-208" href="#__codelineno-7-208"></a> */
</span><span id="__span-7-209"><a id="__codelineno-7-209" name="__codelineno-7-209" href="#__codelineno-7-209"></a>def evaluate(env: Env, expr: Term): Value = match expr {
</span><span id="__span-7-210"><a id="__codelineno-7-210" name="__codelineno-7-210" href="#__codelineno-7-210"></a>    // Look up the variable&#39;s value.
</span><span id="__span-7-211"><a id="__codelineno-7-211" name="__codelineno-7-211" href="#__codelineno-7-211"></a>    case Term::Var(name) =&gt; env.get(name).unwrap[TypedValue].value
</span><span id="__span-7-212"><a id="__codelineno-7-212" name="__codelineno-7-212" href="#__codelineno-7-212"></a>    // A type evaluates to itself.
</span><span id="__span-7-213"><a id="__codelineno-7-213" name="__codelineno-7-213" href="#__codelineno-7-213"></a>    case Term::Type(univ) =&gt; Value::Type(univ)
</span><span id="__span-7-214"><a id="__codelineno-7-214" name="__codelineno-7-214" href="#__codelineno-7-214"></a>    // Lambda Evaluation: Constructs a closure capturing the environment and parameter.
</span><span id="__span-7-215"><a id="__codelineno-7-215" name="__codelineno-7-215" href="#__codelineno-7-215"></a>    case Term::Lambda(paramIdent, paramTypeTerm, bodyTerm) =&gt; {
</span><span id="__span-7-216"><a id="__codelineno-7-216" name="__codelineno-7-216" href="#__codelineno-7-216"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-7-217"><a id="__codelineno-7-217" name="__codelineno-7-217" href="#__codelineno-7-217"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-7-218"><a id="__codelineno-7-218" name="__codelineno-7-218" href="#__codelineno-7-218"></a>            // Evaluate the body with the argument bound.
</span><span id="__span-7-219"><a id="__codelineno-7-219" name="__codelineno-7-219" href="#__codelineno-7-219"></a>            env.add(paramIdent, arg, paramType).evaluate(bodyTerm)
</span><span id="__span-7-220"><a id="__codelineno-7-220" name="__codelineno-7-220" href="#__codelineno-7-220"></a>        }
</span><span id="__span-7-221"><a id="__codelineno-7-221" name="__codelineno-7-221" href="#__codelineno-7-221"></a>        Value::Lambda(paramType, closure)
</span><span id="__span-7-222"><a id="__codelineno-7-222" name="__codelineno-7-222" href="#__codelineno-7-222"></a>    }
</span><span id="__span-7-223"><a id="__codelineno-7-223" name="__codelineno-7-223" href="#__codelineno-7-223"></a>    // Pi Type Evaluation: Similar to lambda
</span><span id="__span-7-224"><a id="__codelineno-7-224" name="__codelineno-7-224" href="#__codelineno-7-224"></a>    case Term::Pi(paramIdent, paramTypeTerm, codomainTerm) =&gt; {
</span><span id="__span-7-225"><a id="__codelineno-7-225" name="__codelineno-7-225" href="#__codelineno-7-225"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-7-226"><a id="__codelineno-7-226" name="__codelineno-7-226" href="#__codelineno-7-226"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-7-227"><a id="__codelineno-7-227" name="__codelineno-7-227" href="#__codelineno-7-227"></a>            // Evaluate codomain with argument bound.
</span><span id="__span-7-228"><a id="__codelineno-7-228" name="__codelineno-7-228" href="#__codelineno-7-228"></a>            env.add(paramIdent, arg, paramType).evaluate(codomainTerm)
</span><span id="__span-7-229"><a id="__codelineno-7-229" name="__codelineno-7-229" href="#__codelineno-7-229"></a>        }
</span><span id="__span-7-230"><a id="__codelineno-7-230" name="__codelineno-7-230" href="#__codelineno-7-230"></a>        Value::Pi(paramType, closure)
</span><span id="__span-7-231"><a id="__codelineno-7-231" name="__codelineno-7-231" href="#__codelineno-7-231"></a>    }
</span><span id="__span-7-232"><a id="__codelineno-7-232" name="__codelineno-7-232" href="#__codelineno-7-232"></a>    // Sigma Type Evaluation: Similar to lambda
</span><span id="__span-7-233"><a id="__codelineno-7-233" name="__codelineno-7-233" href="#__codelineno-7-233"></a>    case Term::Sigma(paramIdent, paramTypeTerm, codomainTerm) =&gt; {
</span><span id="__span-7-234"><a id="__codelineno-7-234" name="__codelineno-7-234" href="#__codelineno-7-234"></a>        let paramType = env.evaluate(paramTypeTerm) // Evaluate parameter type.
</span><span id="__span-7-235"><a id="__codelineno-7-235" name="__codelineno-7-235" href="#__codelineno-7-235"></a>        let closure = (arg: Value) =&gt; {
</span><span id="__span-7-236"><a id="__codelineno-7-236" name="__codelineno-7-236" href="#__codelineno-7-236"></a>            // Evaluate codomain with argument bound.
</span><span id="__span-7-237"><a id="__codelineno-7-237" name="__codelineno-7-237" href="#__codelineno-7-237"></a>            env.add(paramIdent, arg, paramType).evaluate(codomainTerm)
</span><span id="__span-7-238"><a id="__codelineno-7-238" name="__codelineno-7-238" href="#__codelineno-7-238"></a>        }
</span><span id="__span-7-239"><a id="__codelineno-7-239" name="__codelineno-7-239" href="#__codelineno-7-239"></a>        Value::Sigma(paramType, closure)
</span><span id="__span-7-240"><a id="__codelineno-7-240" name="__codelineno-7-240" href="#__codelineno-7-240"></a>    }
</span><span id="__span-7-241"><a id="__codelineno-7-241" name="__codelineno-7-241" href="#__codelineno-7-241"></a>    // Function Application Evaluation
</span><span id="__span-7-242"><a id="__codelineno-7-242" name="__codelineno-7-242" href="#__codelineno-7-242"></a>    case Term::Apply(fn, arg) =&gt; match env.evaluate(fn) {
</span><span id="__span-7-243"><a id="__codelineno-7-243" name="__codelineno-7-243" href="#__codelineno-7-243"></a>        // Apply function to the argument.
</span><span id="__span-7-244"><a id="__codelineno-7-244" name="__codelineno-7-244" href="#__codelineno-7-244"></a>        case Value::Lambda(_, fn) =&gt; fn(env.evaluate(arg))
</span><span id="__span-7-245"><a id="__codelineno-7-245" name="__codelineno-7-245" href="#__codelineno-7-245"></a>        // Neutral Application: Cannot reduce further; keep it a neutral value.
</span><span id="__span-7-246"><a id="__codelineno-7-246" name="__codelineno-7-246" href="#__codelineno-7-246"></a>        case Value::Neutral(neutral) =&gt; NeutralValue::Apply(neutral, env.evaluate(arg)).toValue
</span><span id="__span-7-247"><a id="__codelineno-7-247" name="__codelineno-7-247" href="#__codelineno-7-247"></a>        case _ =&gt; panic(&quot;Invalid type: not a function&quot;)
</span><span id="__span-7-248"><a id="__codelineno-7-248" name="__codelineno-7-248" href="#__codelineno-7-248"></a>    }
</span><span id="__span-7-249"><a id="__codelineno-7-249" name="__codelineno-7-249" href="#__codelineno-7-249"></a>    // Pair Construction
</span><span id="__span-7-250"><a id="__codelineno-7-250" name="__codelineno-7-250" href="#__codelineno-7-250"></a>    case Term::Pair(fst, snd) =&gt; Value::Pair(env.evaluate(fst), env.evaluate(snd))
</span><span id="__span-7-251"><a id="__codelineno-7-251" name="__codelineno-7-251" href="#__codelineno-7-251"></a>    // Pair Projection
</span><span id="__span-7-252"><a id="__codelineno-7-252" name="__codelineno-7-252" href="#__codelineno-7-252"></a>    case Term::Proj(proj, pair) =&gt; match env.evaluate(pair) {
</span><span id="__span-7-253"><a id="__codelineno-7-253" name="__codelineno-7-253" href="#__codelineno-7-253"></a>        case Value::Pair(fst, snd) =&gt; match proj {
</span><span id="__span-7-254"><a id="__codelineno-7-254" name="__codelineno-7-254" href="#__codelineno-7-254"></a>            case Projection::Fst =&gt; fst
</span><span id="__span-7-255"><a id="__codelineno-7-255" name="__codelineno-7-255" href="#__codelineno-7-255"></a>            case Projection::Snd =&gt; snd
</span><span id="__span-7-256"><a id="__codelineno-7-256" name="__codelineno-7-256" href="#__codelineno-7-256"></a>        }
</span><span id="__span-7-257"><a id="__codelineno-7-257" name="__codelineno-7-257" href="#__codelineno-7-257"></a>        case Value::Neutral(neutral) =&gt; NeutralValue::Proj(proj, neutral).toValue
</span><span id="__span-7-258"><a id="__codelineno-7-258" name="__codelineno-7-258" href="#__codelineno-7-258"></a>        case _ =&gt; panic(&quot;Invalid type: not a pair&quot;)
</span><span id="__span-7-259"><a id="__codelineno-7-259" name="__codelineno-7-259" href="#__codelineno-7-259"></a>    }
</span><span id="__span-7-260"><a id="__codelineno-7-260" name="__codelineno-7-260" href="#__codelineno-7-260"></a>}
</span><span id="__span-7-261"><a id="__codelineno-7-261" name="__codelineno-7-261" href="#__codelineno-7-261"></a>
</span><span id="__span-7-262"><a id="__codelineno-7-262" name="__codelineno-7-262" href="#__codelineno-7-262"></a>/**
</span><span id="__span-7-263"><a id="__codelineno-7-263" name="__codelineno-7-263" href="#__codelineno-7-263"></a> * Converts a `NeutralValue` back into a `Term`, used during normalization to reconstruct
</span><span id="__span-7-264"><a id="__codelineno-7-264" name="__codelineno-7-264" href="#__codelineno-7-264"></a> * terms from evaluated values.
</span><span id="__span-7-265"><a id="__codelineno-7-265" name="__codelineno-7-265" href="#__codelineno-7-265"></a> * @param neutral The `NeutralValue` to convert.
</span><span id="__span-7-266"><a id="__codelineno-7-266" name="__codelineno-7-266" href="#__codelineno-7-266"></a> * @param env The current environment.
</span><span id="__span-7-267"><a id="__codelineno-7-267" name="__codelineno-7-267" href="#__codelineno-7-267"></a> * @return The reconstructed `Term`.
</span><span id="__span-7-268"><a id="__codelineno-7-268" name="__codelineno-7-268" href="#__codelineno-7-268"></a> */
</span><span id="__span-7-269"><a id="__codelineno-7-269" name="__codelineno-7-269" href="#__codelineno-7-269"></a>def readBack(neutral: NeutralValue, env: Env): Term = match neutral {
</span><span id="__span-7-270"><a id="__codelineno-7-270" name="__codelineno-7-270" href="#__codelineno-7-270"></a>    // Convert variable to term.
</span><span id="__span-7-271"><a id="__codelineno-7-271" name="__codelineno-7-271" href="#__codelineno-7-271"></a>    case NeutralValue::Var(name) =&gt; Term::Var(name)
</span><span id="__span-7-272"><a id="__codelineno-7-272" name="__codelineno-7-272" href="#__codelineno-7-272"></a>    // Reconstruct application.
</span><span id="__span-7-273"><a id="__codelineno-7-273" name="__codelineno-7-273" href="#__codelineno-7-273"></a>    case NeutralValue::Apply(fn, arg) =&gt; Term::Apply(fn.readBack(env), arg.readBack(env))
</span><span id="__span-7-274"><a id="__codelineno-7-274" name="__codelineno-7-274" href="#__codelineno-7-274"></a>    // Reconstruct projection.
</span><span id="__span-7-275"><a id="__codelineno-7-275" name="__codelineno-7-275" href="#__codelineno-7-275"></a>    case NeutralValue::Proj(proj, neutral) =&gt; Term::Proj(proj, neutral.readBack(env))
</span><span id="__span-7-276"><a id="__codelineno-7-276" name="__codelineno-7-276" href="#__codelineno-7-276"></a>}
</span><span id="__span-7-277"><a id="__codelineno-7-277" name="__codelineno-7-277" href="#__codelineno-7-277"></a>
</span><span id="__span-7-278"><a id="__codelineno-7-278" name="__codelineno-7-278" href="#__codelineno-7-278"></a>/**
</span><span id="__span-7-279"><a id="__codelineno-7-279" name="__codelineno-7-279" href="#__codelineno-7-279"></a> * Converts a `Value` back into a `Term`, effectively normalizing the term by reducing it to its simplest form.
</span><span id="__span-7-280"><a id="__codelineno-7-280" name="__codelineno-7-280" href="#__codelineno-7-280"></a> * @param value The `Value` to convert.
</span><span id="__span-7-281"><a id="__codelineno-7-281" name="__codelineno-7-281" href="#__codelineno-7-281"></a> * @param env The current environment.
</span><span id="__span-7-282"><a id="__codelineno-7-282" name="__codelineno-7-282" href="#__codelineno-7-282"></a> * @return The normalized `Term`.
</span><span id="__span-7-283"><a id="__codelineno-7-283" name="__codelineno-7-283" href="#__codelineno-7-283"></a> */
</span><span id="__span-7-284"><a id="__codelineno-7-284" name="__codelineno-7-284" href="#__codelineno-7-284"></a>def readBack(value: Value, env: Env): Term = match value {
</span><span id="__span-7-285"><a id="__codelineno-7-285" name="__codelineno-7-285" href="#__codelineno-7-285"></a>    case Value::Neutral(neutral) =&gt; neutral.readBack(env)
</span><span id="__span-7-286"><a id="__codelineno-7-286" name="__codelineno-7-286" href="#__codelineno-7-286"></a>    case Value::Type(univ) =&gt; Term::Type(univ)
</span><span id="__span-7-287"><a id="__codelineno-7-287" name="__codelineno-7-287" href="#__codelineno-7-287"></a>    case Value::Pair(fst, snd) =&gt; Term::Pair(fst.readBack(env), snd.readBack(env))
</span><span id="__span-7-288"><a id="__codelineno-7-288" name="__codelineno-7-288" href="#__codelineno-7-288"></a>
</span><span id="__span-7-289"><a id="__codelineno-7-289" name="__codelineno-7-289" href="#__codelineno-7-289"></a>    // Lambda Normalization: Generate a fresh variable to avoid capture.
</span><span id="__span-7-290"><a id="__codelineno-7-290" name="__codelineno-7-290" href="#__codelineno-7-290"></a>    case Value::Lambda(paramType, fn) =&gt; {
</span><span id="__span-7-291"><a id="__codelineno-7-291" name="__codelineno-7-291" href="#__codelineno-7-291"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-7-292"><a id="__codelineno-7-292" name="__codelineno-7-292" href="#__codelineno-7-292"></a>        // Normalize parameter type.
</span><span id="__span-7-293"><a id="__codelineno-7-293" name="__codelineno-7-293" href="#__codelineno-7-293"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-7-294"><a id="__codelineno-7-294" name="__codelineno-7-294" href="#__codelineno-7-294"></a>        // Create variable value.
</span><span id="__span-7-295"><a id="__codelineno-7-295" name="__codelineno-7-295" href="#__codelineno-7-295"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-296"><a id="__codelineno-7-296" name="__codelineno-7-296" href="#__codelineno-7-296"></a>        // Extend environment.
</span><span id="__span-7-297"><a id="__codelineno-7-297" name="__codelineno-7-297" href="#__codelineno-7-297"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-7-298"><a id="__codelineno-7-298" name="__codelineno-7-298" href="#__codelineno-7-298"></a>        Term::Lambda(
</span><span id="__span-7-299"><a id="__codelineno-7-299" name="__codelineno-7-299" href="#__codelineno-7-299"></a>            paramIdent, paramTypeTerm,         // Construct lambda term.
</span><span id="__span-7-300"><a id="__codelineno-7-300" name="__codelineno-7-300" href="#__codelineno-7-300"></a>            fn(variable).readBack(updatedEnv)  // Normalize the body.
</span><span id="__span-7-301"><a id="__codelineno-7-301" name="__codelineno-7-301" href="#__codelineno-7-301"></a>        )
</span><span id="__span-7-302"><a id="__codelineno-7-302" name="__codelineno-7-302" href="#__codelineno-7-302"></a>    }
</span><span id="__span-7-303"><a id="__codelineno-7-303" name="__codelineno-7-303" href="#__codelineno-7-303"></a>
</span><span id="__span-7-304"><a id="__codelineno-7-304" name="__codelineno-7-304" href="#__codelineno-7-304"></a>    // Pi Type Normalization: Similar to lambda normalization.
</span><span id="__span-7-305"><a id="__codelineno-7-305" name="__codelineno-7-305" href="#__codelineno-7-305"></a>    case Value::Pi(paramType, fn) =&gt; {
</span><span id="__span-7-306"><a id="__codelineno-7-306" name="__codelineno-7-306" href="#__codelineno-7-306"></a>        // Fresh parameter name.
</span><span id="__span-7-307"><a id="__codelineno-7-307" name="__codelineno-7-307" href="#__codelineno-7-307"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-7-308"><a id="__codelineno-7-308" name="__codelineno-7-308" href="#__codelineno-7-308"></a>        // Normalize parameter type.
</span><span id="__span-7-309"><a id="__codelineno-7-309" name="__codelineno-7-309" href="#__codelineno-7-309"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-7-310"><a id="__codelineno-7-310" name="__codelineno-7-310" href="#__codelineno-7-310"></a>        // Create variable value.
</span><span id="__span-7-311"><a id="__codelineno-7-311" name="__codelineno-7-311" href="#__codelineno-7-311"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-312"><a id="__codelineno-7-312" name="__codelineno-7-312" href="#__codelineno-7-312"></a>        // Extend environment.
</span><span id="__span-7-313"><a id="__codelineno-7-313" name="__codelineno-7-313" href="#__codelineno-7-313"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-7-314"><a id="__codelineno-7-314" name="__codelineno-7-314" href="#__codelineno-7-314"></a>        Term::Pi(
</span><span id="__span-7-315"><a id="__codelineno-7-315" name="__codelineno-7-315" href="#__codelineno-7-315"></a>            paramIdent, paramTypeTerm,          // Construct Pi type term.
</span><span id="__span-7-316"><a id="__codelineno-7-316" name="__codelineno-7-316" href="#__codelineno-7-316"></a>            fn(variable).readBack(updatedEnv)   // Normalize the codomain.
</span><span id="__span-7-317"><a id="__codelineno-7-317" name="__codelineno-7-317" href="#__codelineno-7-317"></a>        )
</span><span id="__span-7-318"><a id="__codelineno-7-318" name="__codelineno-7-318" href="#__codelineno-7-318"></a>    }
</span><span id="__span-7-319"><a id="__codelineno-7-319" name="__codelineno-7-319" href="#__codelineno-7-319"></a>
</span><span id="__span-7-320"><a id="__codelineno-7-320" name="__codelineno-7-320" href="#__codelineno-7-320"></a>    // Sigma Type Normalization: Similar to lambda normalization.
</span><span id="__span-7-321"><a id="__codelineno-7-321" name="__codelineno-7-321" href="#__codelineno-7-321"></a>    case Value::Sigma(paramType, fn) =&gt; {
</span><span id="__span-7-322"><a id="__codelineno-7-322" name="__codelineno-7-322" href="#__codelineno-7-322"></a>        // Fresh parameter name.
</span><span id="__span-7-323"><a id="__codelineno-7-323" name="__codelineno-7-323" href="#__codelineno-7-323"></a>        let paramIdent: String = env.freshIdent
</span><span id="__span-7-324"><a id="__codelineno-7-324" name="__codelineno-7-324" href="#__codelineno-7-324"></a>        // Normalize parameter type.
</span><span id="__span-7-325"><a id="__codelineno-7-325" name="__codelineno-7-325" href="#__codelineno-7-325"></a>        let paramTypeTerm = paramType.readBack(env)
</span><span id="__span-7-326"><a id="__codelineno-7-326" name="__codelineno-7-326" href="#__codelineno-7-326"></a>        // Create variable value.
</span><span id="__span-7-327"><a id="__codelineno-7-327" name="__codelineno-7-327" href="#__codelineno-7-327"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-328"><a id="__codelineno-7-328" name="__codelineno-7-328" href="#__codelineno-7-328"></a>        // Extend environment.
</span><span id="__span-7-329"><a id="__codelineno-7-329" name="__codelineno-7-329" href="#__codelineno-7-329"></a>        let updatedEnv = env.add(paramIdent, variable, env.evaluate(paramTypeTerm))
</span><span id="__span-7-330"><a id="__codelineno-7-330" name="__codelineno-7-330" href="#__codelineno-7-330"></a>        Term::Sigma(
</span><span id="__span-7-331"><a id="__codelineno-7-331" name="__codelineno-7-331" href="#__codelineno-7-331"></a>            paramIdent, paramTypeTerm,          // Construct Sigma type term.
</span><span id="__span-7-332"><a id="__codelineno-7-332" name="__codelineno-7-332" href="#__codelineno-7-332"></a>            fn(variable).readBack(updatedEnv)   // Normalize the codomain.
</span><span id="__span-7-333"><a id="__codelineno-7-333" name="__codelineno-7-333" href="#__codelineno-7-333"></a>        )
</span><span id="__span-7-334"><a id="__codelineno-7-334" name="__codelineno-7-334" href="#__codelineno-7-334"></a>    }
</span><span id="__span-7-335"><a id="__codelineno-7-335" name="__codelineno-7-335" href="#__codelineno-7-335"></a>}
</span><span id="__span-7-336"><a id="__codelineno-7-336" name="__codelineno-7-336" href="#__codelineno-7-336"></a>
</span><span id="__span-7-337"><a id="__codelineno-7-337" name="__codelineno-7-337" href="#__codelineno-7-337"></a>/**
</span><span id="__span-7-338"><a id="__codelineno-7-338" name="__codelineno-7-338" href="#__codelineno-7-338"></a> * Retrieves the universe level from a `Type` value.
</span><span id="__span-7-339"><a id="__codelineno-7-339" name="__codelineno-7-339" href="#__codelineno-7-339"></a> * Universe levels are critical in MLTT to maintain consistency and avoid paradoxes.
</span><span id="__span-7-340"><a id="__codelineno-7-340" name="__codelineno-7-340" href="#__codelineno-7-340"></a> * @param ty The `Type` value.
</span><span id="__span-7-341"><a id="__codelineno-7-341" name="__codelineno-7-341" href="#__codelineno-7-341"></a> * @return The universe level as an `Int`.
</span><span id="__span-7-342"><a id="__codelineno-7-342" name="__codelineno-7-342" href="#__codelineno-7-342"></a> */
</span><span id="__span-7-343"><a id="__codelineno-7-343" name="__codelineno-7-343" href="#__codelineno-7-343"></a>def universeLevel(ty: Type): Int = match ty {
</span><span id="__span-7-344"><a id="__codelineno-7-344" name="__codelineno-7-344" href="#__codelineno-7-344"></a>    case Value::Type(univ) =&gt; univ                                  // Extract universe level.
</span><span id="__span-7-345"><a id="__codelineno-7-345" name="__codelineno-7-345" href="#__codelineno-7-345"></a>    case _ =&gt; panic(&quot;Failed to unwrap universe level: not a type&quot;)  // Panic if not a type.
</span><span id="__span-7-346"><a id="__codelineno-7-346" name="__codelineno-7-346" href="#__codelineno-7-346"></a>}
</span><span id="__span-7-347"><a id="__codelineno-7-347" name="__codelineno-7-347" href="#__codelineno-7-347"></a>
</span><span id="__span-7-348"><a id="__codelineno-7-348" name="__codelineno-7-348" href="#__codelineno-7-348"></a>/**
</span><span id="__span-7-349"><a id="__codelineno-7-349" name="__codelineno-7-349" href="#__codelineno-7-349"></a> * Infers the type of a `Term` within a given environment following MLTT&#39;s typing rules.
</span><span id="__span-7-350"><a id="__codelineno-7-350" name="__codelineno-7-350" href="#__codelineno-7-350"></a> * @param env The current environment.
</span><span id="__span-7-351"><a id="__codelineno-7-351" name="__codelineno-7-351" href="#__codelineno-7-351"></a> * @param expr The `Term` whose type is inferred.
</span><span id="__span-7-352"><a id="__codelineno-7-352" name="__codelineno-7-352" href="#__codelineno-7-352"></a> * @return The inferred type as a `Value`.
</span><span id="__span-7-353"><a id="__codelineno-7-353" name="__codelineno-7-353" href="#__codelineno-7-353"></a> */
</span><span id="__span-7-354"><a id="__codelineno-7-354" name="__codelineno-7-354" href="#__codelineno-7-354"></a>def infer(env: Env, expr: Term): Value = match expr {
</span><span id="__span-7-355"><a id="__codelineno-7-355" name="__codelineno-7-355" href="#__codelineno-7-355"></a>
</span><span id="__span-7-356"><a id="__codelineno-7-356" name="__codelineno-7-356" href="#__codelineno-7-356"></a>    // Retrieve the variable&#39;s type from the environment.
</span><span id="__span-7-357"><a id="__codelineno-7-357" name="__codelineno-7-357" href="#__codelineno-7-357"></a>    case Term::Var(name) =&gt; env.get(name).unwrap[TypedValue].ty
</span><span id="__span-7-358"><a id="__codelineno-7-358" name="__codelineno-7-358" href="#__codelineno-7-358"></a>
</span><span id="__span-7-359"><a id="__codelineno-7-359" name="__codelineno-7-359" href="#__codelineno-7-359"></a>    // `Type(n)` has type `Type(n + 1)`.
</span><span id="__span-7-360"><a id="__codelineno-7-360" name="__codelineno-7-360" href="#__codelineno-7-360"></a>    case Term::Type(univ) =&gt; Value::Type(univ + 1)
</span><span id="__span-7-361"><a id="__codelineno-7-361" name="__codelineno-7-361" href="#__codelineno-7-361"></a>
</span><span id="__span-7-362"><a id="__codelineno-7-362" name="__codelineno-7-362" href="#__codelineno-7-362"></a>    // Lambda Type Inference:
</span><span id="__span-7-363"><a id="__codelineno-7-363" name="__codelineno-7-363" href="#__codelineno-7-363"></a>    case Term::Lambda(paramIdent, paramTypeTerm, bodyTerm) =&gt; {
</span><span id="__span-7-364"><a id="__codelineno-7-364" name="__codelineno-7-364" href="#__codelineno-7-364"></a>        // Infer parameter type&#39;s universe level.
</span><span id="__span-7-365"><a id="__codelineno-7-365" name="__codelineno-7-365" href="#__codelineno-7-365"></a>        let paramLevel = env.infer(paramTypeTerm).universeLevel
</span><span id="__span-7-366"><a id="__codelineno-7-366" name="__codelineno-7-366" href="#__codelineno-7-366"></a>        // Evaluate parameter type.
</span><span id="__span-7-367"><a id="__codelineno-7-367" name="__codelineno-7-367" href="#__codelineno-7-367"></a>        let paramType: Type = env.evaluate(paramTypeTerm)
</span><span id="__span-7-368"><a id="__codelineno-7-368" name="__codelineno-7-368" href="#__codelineno-7-368"></a>        // Create variable for parameter.
</span><span id="__span-7-369"><a id="__codelineno-7-369" name="__codelineno-7-369" href="#__codelineno-7-369"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-370"><a id="__codelineno-7-370" name="__codelineno-7-370" href="#__codelineno-7-370"></a>        // Extend environment with parameter.
</span><span id="__span-7-371"><a id="__codelineno-7-371" name="__codelineno-7-371" href="#__codelineno-7-371"></a>        let bodyEnv = env.add(paramIdent, variable, paramType)
</span><span id="__span-7-372"><a id="__codelineno-7-372" name="__codelineno-7-372" href="#__codelineno-7-372"></a>        // Infer body&#39;s type.
</span><span id="__span-7-373"><a id="__codelineno-7-373" name="__codelineno-7-373" href="#__codelineno-7-373"></a>        let returnType: Type = bodyEnv.infer(bodyTerm)
</span><span id="__span-7-374"><a id="__codelineno-7-374" name="__codelineno-7-374" href="#__codelineno-7-374"></a>        // The lambda&#39;s type is a Pi type from parameter to return type.
</span><span id="__span-7-375"><a id="__codelineno-7-375" name="__codelineno-7-375" href="#__codelineno-7-375"></a>        Value::Pi(
</span><span id="__span-7-376"><a id="__codelineno-7-376" name="__codelineno-7-376" href="#__codelineno-7-376"></a>            paramType,
</span><span id="__span-7-377"><a id="__codelineno-7-377" name="__codelineno-7-377" href="#__codelineno-7-377"></a>            (arg: Value) =&gt; {
</span><span id="__span-7-378"><a id="__codelineno-7-378" name="__codelineno-7-378" href="#__codelineno-7-378"></a>                // Infer argument&#39;s type.
</span><span id="__span-7-379"><a id="__codelineno-7-379" name="__codelineno-7-379" href="#__codelineno-7-379"></a>                let argType = env.infer(arg.readBack(bodyEnv))
</span><span id="__span-7-380"><a id="__codelineno-7-380" name="__codelineno-7-380" href="#__codelineno-7-380"></a>                // Evaluate the body.
</span><span id="__span-7-381"><a id="__codelineno-7-381" name="__codelineno-7-381" href="#__codelineno-7-381"></a>                bodyEnv.add(paramIdent, arg, argType).evaluate(bodyTerm)
</span><span id="__span-7-382"><a id="__codelineno-7-382" name="__codelineno-7-382" href="#__codelineno-7-382"></a>            }
</span><span id="__span-7-383"><a id="__codelineno-7-383" name="__codelineno-7-383" href="#__codelineno-7-383"></a>        )
</span><span id="__span-7-384"><a id="__codelineno-7-384" name="__codelineno-7-384" href="#__codelineno-7-384"></a>    }
</span><span id="__span-7-385"><a id="__codelineno-7-385" name="__codelineno-7-385" href="#__codelineno-7-385"></a>
</span><span id="__span-7-386"><a id="__codelineno-7-386" name="__codelineno-7-386" href="#__codelineno-7-386"></a>    // Pair Type Inference:
</span><span id="__span-7-387"><a id="__codelineno-7-387" name="__codelineno-7-387" href="#__codelineno-7-387"></a>    case Term::Pair(fst, snd) =&gt; {
</span><span id="__span-7-388"><a id="__codelineno-7-388" name="__codelineno-7-388" href="#__codelineno-7-388"></a>        // Infer the type of the first element.
</span><span id="__span-7-389"><a id="__codelineno-7-389" name="__codelineno-7-389" href="#__codelineno-7-389"></a>        let fstType: Type = env.infer(fst)
</span><span id="__span-7-390"><a id="__codelineno-7-390" name="__codelineno-7-390" href="#__codelineno-7-390"></a>        // Infer the type of the second element.
</span><span id="__span-7-391"><a id="__codelineno-7-391" name="__codelineno-7-391" href="#__codelineno-7-391"></a>        let sndType: Type = env.infer(snd)
</span><span id="__span-7-392"><a id="__codelineno-7-392" name="__codelineno-7-392" href="#__codelineno-7-392"></a>        // The pair type is a Sigma type of the two elements.
</span><span id="__span-7-393"><a id="__codelineno-7-393" name="__codelineno-7-393" href="#__codelineno-7-393"></a>        Value::Sigma(fstType, (fstValue: Value) =&gt; {
</span><span id="__span-7-394"><a id="__codelineno-7-394" name="__codelineno-7-394" href="#__codelineno-7-394"></a>            Value::Sigma(sndType, (sndValue: Value) =&gt; Value::Pair(fstValue, sndValue))
</span><span id="__span-7-395"><a id="__codelineno-7-395" name="__codelineno-7-395" href="#__codelineno-7-395"></a>        })
</span><span id="__span-7-396"><a id="__codelineno-7-396" name="__codelineno-7-396" href="#__codelineno-7-396"></a>    }
</span><span id="__span-7-397"><a id="__codelineno-7-397" name="__codelineno-7-397" href="#__codelineno-7-397"></a>
</span><span id="__span-7-398"><a id="__codelineno-7-398" name="__codelineno-7-398" href="#__codelineno-7-398"></a>    // Pi Type Inference:
</span><span id="__span-7-399"><a id="__codelineno-7-399" name="__codelineno-7-399" href="#__codelineno-7-399"></a>    case Term::Pi(paramIdent, paramTypeTerm, returnTypeTerm) =&gt; {
</span><span id="__span-7-400"><a id="__codelineno-7-400" name="__codelineno-7-400" href="#__codelineno-7-400"></a>        // Infer parameter type&#39;s universe level.
</span><span id="__span-7-401"><a id="__codelineno-7-401" name="__codelineno-7-401" href="#__codelineno-7-401"></a>        let paramLevel = env.infer(paramTypeTerm).universeLevel
</span><span id="__span-7-402"><a id="__codelineno-7-402" name="__codelineno-7-402" href="#__codelineno-7-402"></a>        // Evaluate parameter type.
</span><span id="__span-7-403"><a id="__codelineno-7-403" name="__codelineno-7-403" href="#__codelineno-7-403"></a>        let paramType: Type = env.evaluate(paramTypeTerm)
</span><span id="__span-7-404"><a id="__codelineno-7-404" name="__codelineno-7-404" href="#__codelineno-7-404"></a>        // Create variable for parameter.
</span><span id="__span-7-405"><a id="__codelineno-7-405" name="__codelineno-7-405" href="#__codelineno-7-405"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-406"><a id="__codelineno-7-406" name="__codelineno-7-406" href="#__codelineno-7-406"></a>        let returnTypeLevel = env.add(paramIdent, variable, paramType).infer(returnTypeTerm).universeLevel
</span><span id="__span-7-407"><a id="__codelineno-7-407" name="__codelineno-7-407" href="#__codelineno-7-407"></a>        // The Pi type&#39;s universe level is the maximum of parameter and return types.
</span><span id="__span-7-408"><a id="__codelineno-7-408" name="__codelineno-7-408" href="#__codelineno-7-408"></a>        Value::Type(max paramLevel returnTypeLevel)
</span><span id="__span-7-409"><a id="__codelineno-7-409" name="__codelineno-7-409" href="#__codelineno-7-409"></a>    }
</span><span id="__span-7-410"><a id="__codelineno-7-410" name="__codelineno-7-410" href="#__codelineno-7-410"></a>
</span><span id="__span-7-411"><a id="__codelineno-7-411" name="__codelineno-7-411" href="#__codelineno-7-411"></a>    // Sigma Type Inference:
</span><span id="__span-7-412"><a id="__codelineno-7-412" name="__codelineno-7-412" href="#__codelineno-7-412"></a>    case Term::Sigma(paramIdent, paramTypeTerm, codomainTerm) =&gt; {
</span><span id="__span-7-413"><a id="__codelineno-7-413" name="__codelineno-7-413" href="#__codelineno-7-413"></a>        // Infer parameter type&#39;s universe level.
</span><span id="__span-7-414"><a id="__codelineno-7-414" name="__codelineno-7-414" href="#__codelineno-7-414"></a>        let paramLevel = env.infer(paramTypeTerm).universeLevel
</span><span id="__span-7-415"><a id="__codelineno-7-415" name="__codelineno-7-415" href="#__codelineno-7-415"></a>        // Evaluate parameter type.
</span><span id="__span-7-416"><a id="__codelineno-7-416" name="__codelineno-7-416" href="#__codelineno-7-416"></a>        let paramType: Type = env.evaluate(paramTypeTerm)
</span><span id="__span-7-417"><a id="__codelineno-7-417" name="__codelineno-7-417" href="#__codelineno-7-417"></a>        // Create variable for parameter.
</span><span id="__span-7-418"><a id="__codelineno-7-418" name="__codelineno-7-418" href="#__codelineno-7-418"></a>        let variable: Value = NeutralValue::Var(paramIdent).toValue
</span><span id="__span-7-419"><a id="__codelineno-7-419" name="__codelineno-7-419" href="#__codelineno-7-419"></a>        let rhsTypeLevel = env.add(paramIdent, variable, paramType).infer(codomainTerm).universeLevel
</span><span id="__span-7-420"><a id="__codelineno-7-420" name="__codelineno-7-420" href="#__codelineno-7-420"></a>        // The sigma type&#39;s universe level is the maximum of lhs and rhs types.
</span><span id="__span-7-421"><a id="__codelineno-7-421" name="__codelineno-7-421" href="#__codelineno-7-421"></a>        Value::Type(max paramLevel rhsTypeLevel)
</span><span id="__span-7-422"><a id="__codelineno-7-422" name="__codelineno-7-422" href="#__codelineno-7-422"></a>    }
</span><span id="__span-7-423"><a id="__codelineno-7-423" name="__codelineno-7-423" href="#__codelineno-7-423"></a>}
</span><span id="__span-7-424"><a id="__codelineno-7-424" name="__codelineno-7-424" href="#__codelineno-7-424"></a>
</span><span id="__span-7-425"><a id="__codelineno-7-425" name="__codelineno-7-425" href="#__codelineno-7-425"></a>/**
</span><span id="__span-7-426"><a id="__codelineno-7-426" name="__codelineno-7-426" href="#__codelineno-7-426"></a> * Normalizes a `Term` by evaluating it and converting the result back into a term.
</span><span id="__span-7-427"><a id="__codelineno-7-427" name="__codelineno-7-427" href="#__codelineno-7-427"></a> * Normalization is essential for comparing terms for equality and ensuring consistent behavior.
</span><span id="__span-7-428"><a id="__codelineno-7-428" name="__codelineno-7-428" href="#__codelineno-7-428"></a> * @param env The current environment.
</span><span id="__span-7-429"><a id="__codelineno-7-429" name="__codelineno-7-429" href="#__codelineno-7-429"></a> * @param expr The `Term` to normalize.
</span><span id="__span-7-430"><a id="__codelineno-7-430" name="__codelineno-7-430" href="#__codelineno-7-430"></a> * @return The normalized `Term`.
</span><span id="__span-7-431"><a id="__codelineno-7-431" name="__codelineno-7-431" href="#__codelineno-7-431"></a> */
</span><span id="__span-7-432"><a id="__codelineno-7-432" name="__codelineno-7-432" href="#__codelineno-7-432"></a>def normalize(env: Env, expr: Term): Term = env.evaluate(expr).readBack(env)
</span><span id="__span-7-433"><a id="__codelineno-7-433" name="__codelineno-7-433" href="#__codelineno-7-433"></a>
</span><span id="__span-7-434"><a id="__codelineno-7-434" name="__codelineno-7-434" href="#__codelineno-7-434"></a>def pretty(expr: Term): String = match expr {
</span><span id="__span-7-435"><a id="__codelineno-7-435" name="__codelineno-7-435" href="#__codelineno-7-435"></a>    case Term::Var(name) =&gt; name
</span><span id="__span-7-436"><a id="__codelineno-7-436" name="__codelineno-7-436" href="#__codelineno-7-436"></a>    case Term::Type(univ) =&gt; &quot;Type(&quot; ++ univ.toString ++ &quot;)&quot;
</span><span id="__span-7-437"><a id="__codelineno-7-437" name="__codelineno-7-437" href="#__codelineno-7-437"></a>    case Term::Lambda(paramIdent, paramType, body) =&gt;
</span><span id="__span-7-438"><a id="__codelineno-7-438" name="__codelineno-7-438" href="#__codelineno-7-438"></a>        &quot;λ(&quot; ++ paramIdent ++ &quot; : &quot; ++ paramType.pretty ++ &quot;). &quot; ++ body.pretty
</span><span id="__span-7-439"><a id="__codelineno-7-439" name="__codelineno-7-439" href="#__codelineno-7-439"></a>    case Term::Apply(fn, arg) =&gt; &quot;(&quot; ++ fn.prettyAtom ++ &quot; &quot; ++ arg.prettyAtom ++ &quot;)&quot;
</span><span id="__span-7-440"><a id="__codelineno-7-440" name="__codelineno-7-440" href="#__codelineno-7-440"></a>    case Term::Pi(paramIdent, paramType, returnType) =&gt;
</span><span id="__span-7-441"><a id="__codelineno-7-441" name="__codelineno-7-441" href="#__codelineno-7-441"></a>        &quot;Π(&quot; ++ paramIdent ++ &quot; : &quot; ++ paramType.pretty ++ &quot;). &quot; ++ returnType.pretty
</span><span id="__span-7-442"><a id="__codelineno-7-442" name="__codelineno-7-442" href="#__codelineno-7-442"></a>    case Term::Sigma(paramIdent, paramType, codomain) =&gt;
</span><span id="__span-7-443"><a id="__codelineno-7-443" name="__codelineno-7-443" href="#__codelineno-7-443"></a>        &quot;Σ(&quot; ++ paramIdent ++ &quot; : &quot; ++ paramType.pretty ++ &quot;). &quot; ++ codomain.pretty
</span><span id="__span-7-444"><a id="__codelineno-7-444" name="__codelineno-7-444" href="#__codelineno-7-444"></a>    case Term::Pair(fst, snd) =&gt; &quot;(&quot; ++ fst.pretty ++ &quot;, &quot; ++ snd.pretty ++ &quot;)&quot;
</span><span id="__span-7-445"><a id="__codelineno-7-445" name="__codelineno-7-445" href="#__codelineno-7-445"></a>    case Term::Proj(Projection::Fst, pair) =&gt; &quot;fst &quot; ++ pair.pretty
</span><span id="__span-7-446"><a id="__codelineno-7-446" name="__codelineno-7-446" href="#__codelineno-7-446"></a>}
</span><span id="__span-7-447"><a id="__codelineno-7-447" name="__codelineno-7-447" href="#__codelineno-7-447"></a>
</span><span id="__span-7-448"><a id="__codelineno-7-448" name="__codelineno-7-448" href="#__codelineno-7-448"></a>def prettyAtom(expr: Term): String = match expr {
</span><span id="__span-7-449"><a id="__codelineno-7-449" name="__codelineno-7-449" href="#__codelineno-7-449"></a>    case Term::Var(name) =&gt; name
</span><span id="__span-7-450"><a id="__codelineno-7-450" name="__codelineno-7-450" href="#__codelineno-7-450"></a>    case Term::Type(_) =&gt; expr.pretty
</span><span id="__span-7-451"><a id="__codelineno-7-451" name="__codelineno-7-451" href="#__codelineno-7-451"></a>    case Term::Lambda(_, _, _) =&gt; &quot;(&quot; ++ expr.pretty ++ &quot;)&quot;
</span><span id="__span-7-452"><a id="__codelineno-7-452" name="__codelineno-7-452" href="#__codelineno-7-452"></a>    case Term::Apply(_, _) =&gt; &quot;(&quot; ++ expr.pretty ++ &quot;)&quot;
</span><span id="__span-7-453"><a id="__codelineno-7-453" name="__codelineno-7-453" href="#__codelineno-7-453"></a>    case Term::Pi(_, _, _) =&gt; &quot;(&quot; ++ expr.pretty ++ &quot;)&quot;
</span><span id="__span-7-454"><a id="__codelineno-7-454" name="__codelineno-7-454" href="#__codelineno-7-454"></a>    case Term::Sigma(_, _, _) =&gt; &quot;(&quot; ++ expr.pretty ++ &quot;)&quot;
</span><span id="__span-7-455"><a id="__codelineno-7-455" name="__codelineno-7-455" href="#__codelineno-7-455"></a>    case Term::Pair(_, _) =&gt; expr.pretty
</span><span id="__span-7-456"><a id="__codelineno-7-456" name="__codelineno-7-456" href="#__codelineno-7-456"></a>    case Term::Proj(_, _) =&gt; &quot;(&quot; ++ expr.pretty ++ &quot;)&quot;
</span><span id="__span-7-457"><a id="__codelineno-7-457" name="__codelineno-7-457" href="#__codelineno-7-457"></a>}
</span><span id="__span-7-458"><a id="__codelineno-7-458" name="__codelineno-7-458" href="#__codelineno-7-458"></a>
</span><span id="__span-7-459"><a id="__codelineno-7-459" name="__codelineno-7-459" href="#__codelineno-7-459"></a>def var(ident: String): Value = NeutralValue::Var(ident).toValue
</span><span id="__span-7-460"><a id="__codelineno-7-460" name="__codelineno-7-460" href="#__codelineno-7-460"></a>
</span><span id="__span-7-461"><a id="__codelineno-7-461" name="__codelineno-7-461" href="#__codelineno-7-461"></a>def prelude: Env = Env::Empty
</span><span id="__span-7-462"><a id="__codelineno-7-462" name="__codelineno-7-462" href="#__codelineno-7-462"></a>    .addVar(&quot;Any&quot;, Value::Type(0))
</span><span id="__span-7-463"><a id="__codelineno-7-463" name="__codelineno-7-463" href="#__codelineno-7-463"></a>    .addVar(&quot;Nothing&quot;, Value::Type(0))
</span><span id="__span-7-464"><a id="__codelineno-7-464" name="__codelineno-7-464" href="#__codelineno-7-464"></a>    .addVar(&quot;Bool&quot;, Value::Type(0))
</span><span id="__span-7-465"><a id="__codelineno-7-465" name="__codelineno-7-465" href="#__codelineno-7-465"></a>    .addVar(&quot;true&quot;, var(&quot;Bool&quot;))
</span><span id="__span-7-466"><a id="__codelineno-7-466" name="__codelineno-7-466" href="#__codelineno-7-466"></a>    .addVar(&quot;false&quot;, var(&quot;Bool&quot;))
</span><span id="__span-7-467"><a id="__codelineno-7-467" name="__codelineno-7-467" href="#__codelineno-7-467"></a>    .addVar(&quot;Nat&quot;, Value::Type(0))
</span><span id="__span-7-468"><a id="__codelineno-7-468" name="__codelineno-7-468" href="#__codelineno-7-468"></a>    .addVar(&quot;zero&quot;, var(&quot;Nat&quot;))
</span><span id="__span-7-469"><a id="__codelineno-7-469" name="__codelineno-7-469" href="#__codelineno-7-469"></a>    .addVar(&quot;succ&quot;, Value::Pi(var(&quot;Nat&quot;), (n: Value) =&gt; var(&quot;Nat&quot;)))
</span><span id="__span-7-470"><a id="__codelineno-7-470" name="__codelineno-7-470" href="#__codelineno-7-470"></a>
</span><span id="__span-7-471"><a id="__codelineno-7-471" name="__codelineno-7-471" href="#__codelineno-7-471"></a>eval &quot;\nBeta-reduction: (λx. t) v -&gt; t[x := v]  Case 1: x[x := N] = N&quot;
</span><span id="__span-7-472"><a id="__codelineno-7-472" name="__codelineno-7-472" href="#__codelineno-7-472"></a>eval {
</span><span id="__span-7-473"><a id="__codelineno-7-473" name="__codelineno-7-473" href="#__codelineno-7-473"></a>    let term: Term = Term::Apply(
</span><span id="__span-7-474"><a id="__codelineno-7-474" name="__codelineno-7-474" href="#__codelineno-7-474"></a>        Term::Lambda(&quot;x&quot;, Term::Var(&quot;Bool&quot;), Term::Var(&quot;x&quot;)),
</span><span id="__span-7-475"><a id="__codelineno-7-475" name="__codelineno-7-475" href="#__codelineno-7-475"></a>        Term::Var(&quot;true&quot;)
</span><span id="__span-7-476"><a id="__codelineno-7-476" name="__codelineno-7-476" href="#__codelineno-7-476"></a>    )
</span><span id="__span-7-477"><a id="__codelineno-7-477" name="__codelineno-7-477" href="#__codelineno-7-477"></a>    term.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(term).pretty
</span><span id="__span-7-478"><a id="__codelineno-7-478" name="__codelineno-7-478" href="#__codelineno-7-478"></a>}
</span><span id="__span-7-479"><a id="__codelineno-7-479" name="__codelineno-7-479" href="#__codelineno-7-479"></a>
</span><span id="__span-7-480"><a id="__codelineno-7-480" name="__codelineno-7-480" href="#__codelineno-7-480"></a>eval &quot;\nBeta-reduction: (λx. t) v -&gt; t[x := v]  Case 2: y[x := N] = y, if x ≠ y&quot;
</span><span id="__span-7-481"><a id="__codelineno-7-481" name="__codelineno-7-481" href="#__codelineno-7-481"></a>eval {
</span><span id="__span-7-482"><a id="__codelineno-7-482" name="__codelineno-7-482" href="#__codelineno-7-482"></a>    let term: Term = Term::Apply(
</span><span id="__span-7-483"><a id="__codelineno-7-483" name="__codelineno-7-483" href="#__codelineno-7-483"></a>        Term::Lambda(
</span><span id="__span-7-484"><a id="__codelineno-7-484" name="__codelineno-7-484" href="#__codelineno-7-484"></a>            &quot;x&quot;, Term::Var(&quot;Bool&quot;),
</span><span id="__span-7-485"><a id="__codelineno-7-485" name="__codelineno-7-485" href="#__codelineno-7-485"></a>            Term::Lambda(&quot;y&quot;, Term::Var(&quot;Bool&quot;), Term::Var(&quot;y&quot;))
</span><span id="__span-7-486"><a id="__codelineno-7-486" name="__codelineno-7-486" href="#__codelineno-7-486"></a>        ),
</span><span id="__span-7-487"><a id="__codelineno-7-487" name="__codelineno-7-487" href="#__codelineno-7-487"></a>        Term::Var(&quot;true&quot;)
</span><span id="__span-7-488"><a id="__codelineno-7-488" name="__codelineno-7-488" href="#__codelineno-7-488"></a>    )
</span><span id="__span-7-489"><a id="__codelineno-7-489" name="__codelineno-7-489" href="#__codelineno-7-489"></a>    term.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(term).pretty
</span><span id="__span-7-490"><a id="__codelineno-7-490" name="__codelineno-7-490" href="#__codelineno-7-490"></a>}
</span><span id="__span-7-491"><a id="__codelineno-7-491" name="__codelineno-7-491" href="#__codelineno-7-491"></a>
</span><span id="__span-7-492"><a id="__codelineno-7-492" name="__codelineno-7-492" href="#__codelineno-7-492"></a>eval &quot;\nHigher-order function:&quot;
</span><span id="__span-7-493"><a id="__codelineno-7-493" name="__codelineno-7-493" href="#__codelineno-7-493"></a>eval {
</span><span id="__span-7-494"><a id="__codelineno-7-494" name="__codelineno-7-494" href="#__codelineno-7-494"></a>    let term = Term::Apply(
</span><span id="__span-7-495"><a id="__codelineno-7-495" name="__codelineno-7-495" href="#__codelineno-7-495"></a>        Term::Lambda(&quot;f&quot;, Term::Pi(&quot;x&quot;, Term::Var(&quot;Bool&quot;), Term::Var(&quot;Bool&quot;)),
</span><span id="__span-7-496"><a id="__codelineno-7-496" name="__codelineno-7-496" href="#__codelineno-7-496"></a>            Term::Apply(Term::Var(&quot;f&quot;), Term::Var(&quot;true&quot;))
</span><span id="__span-7-497"><a id="__codelineno-7-497" name="__codelineno-7-497" href="#__codelineno-7-497"></a>        ),
</span><span id="__span-7-498"><a id="__codelineno-7-498" name="__codelineno-7-498" href="#__codelineno-7-498"></a>        Term::Lambda(&quot;x&quot;, Term::Var(&quot;Bool&quot;), Term::Var(&quot;x&quot;))
</span><span id="__span-7-499"><a id="__codelineno-7-499" name="__codelineno-7-499" href="#__codelineno-7-499"></a>    )
</span><span id="__span-7-500"><a id="__codelineno-7-500" name="__codelineno-7-500" href="#__codelineno-7-500"></a>    term.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(term).pretty
</span><span id="__span-7-501"><a id="__codelineno-7-501" name="__codelineno-7-501" href="#__codelineno-7-501"></a>}
</span><span id="__span-7-502"><a id="__codelineno-7-502" name="__codelineno-7-502" href="#__codelineno-7-502"></a>
</span><span id="__span-7-503"><a id="__codelineno-7-503" name="__codelineno-7-503" href="#__codelineno-7-503"></a>eval &quot;\nAlpha-conversion: λx. t -&gt; λy. t[x := y] -- no name collision&quot;
</span><span id="__span-7-504"><a id="__codelineno-7-504" name="__codelineno-7-504" href="#__codelineno-7-504"></a>eval {
</span><span id="__span-7-505"><a id="__codelineno-7-505" name="__codelineno-7-505" href="#__codelineno-7-505"></a>    let term = Term::Pi(&quot;A&quot;, Term::Type(0),
</span><span id="__span-7-506"><a id="__codelineno-7-506" name="__codelineno-7-506" href="#__codelineno-7-506"></a>        Term::Lambda(&quot;x&quot;, Term::Var(&quot;A&quot;), Term::Var(&quot;x&quot;))
</span><span id="__span-7-507"><a id="__codelineno-7-507" name="__codelineno-7-507" href="#__codelineno-7-507"></a>    )
</span><span id="__span-7-508"><a id="__codelineno-7-508" name="__codelineno-7-508" href="#__codelineno-7-508"></a>    term.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(term).pretty
</span><span id="__span-7-509"><a id="__codelineno-7-509" name="__codelineno-7-509" href="#__codelineno-7-509"></a>}
</span><span id="__span-7-510"><a id="__codelineno-7-510" name="__codelineno-7-510" href="#__codelineno-7-510"></a>
</span><span id="__span-7-511"><a id="__codelineno-7-511" name="__codelineno-7-511" href="#__codelineno-7-511"></a>eval &quot;\nSigma type - elimination&quot;
</span><span id="__span-7-512"><a id="__codelineno-7-512" name="__codelineno-7-512" href="#__codelineno-7-512"></a>eval {
</span><span id="__span-7-513"><a id="__codelineno-7-513" name="__codelineno-7-513" href="#__codelineno-7-513"></a>    let term = Term::Apply(
</span><span id="__span-7-514"><a id="__codelineno-7-514" name="__codelineno-7-514" href="#__codelineno-7-514"></a>        Term::Lambda(&quot;p&quot;, Term::Sigma(&quot;A&quot;, Term::Var(&quot;Bool&quot;), Term::Var(&quot;A&quot;)),
</span><span id="__span-7-515"><a id="__codelineno-7-515" name="__codelineno-7-515" href="#__codelineno-7-515"></a>            Term::Proj(Projection::Fst, Term::Var(&quot;p&quot;))
</span><span id="__span-7-516"><a id="__codelineno-7-516" name="__codelineno-7-516" href="#__codelineno-7-516"></a>        ),
</span><span id="__span-7-517"><a id="__codelineno-7-517" name="__codelineno-7-517" href="#__codelineno-7-517"></a>        Term::Pair(Term::Var(&quot;true&quot;), Term::Var(&quot;false&quot;))
</span><span id="__span-7-518"><a id="__codelineno-7-518" name="__codelineno-7-518" href="#__codelineno-7-518"></a>    )
</span><span id="__span-7-519"><a id="__codelineno-7-519" name="__codelineno-7-519" href="#__codelineno-7-519"></a>    term.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(term).pretty
</span><span id="__span-7-520"><a id="__codelineno-7-520" name="__codelineno-7-520" href="#__codelineno-7-520"></a>}
</span><span id="__span-7-521"><a id="__codelineno-7-521" name="__codelineno-7-521" href="#__codelineno-7-521"></a>
</span><span id="__span-7-522"><a id="__codelineno-7-522" name="__codelineno-7-522" href="#__codelineno-7-522"></a>eval &quot;\nChurch numeral 0:&quot;
</span><span id="__span-7-523"><a id="__codelineno-7-523" name="__codelineno-7-523" href="#__codelineno-7-523"></a>eval {
</span><span id="__span-7-524"><a id="__codelineno-7-524" name="__codelineno-7-524" href="#__codelineno-7-524"></a>    let zero = Term::Lambda(&quot;f&quot;, Term::Pi(&quot;x&quot;, Term::Var(&quot;Any&quot;), Term::Var(&quot;Any&quot;)),
</span><span id="__span-7-525"><a id="__codelineno-7-525" name="__codelineno-7-525" href="#__codelineno-7-525"></a>        Term::Lambda(&quot;x&quot;, Term::Var(&quot;Any&quot;), Term::Var(&quot;x&quot;))
</span><span id="__span-7-526"><a id="__codelineno-7-526" name="__codelineno-7-526" href="#__codelineno-7-526"></a>    )
</span><span id="__span-7-527"><a id="__codelineno-7-527" name="__codelineno-7-527" href="#__codelineno-7-527"></a>    zero.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(zero).pretty
</span><span id="__span-7-528"><a id="__codelineno-7-528" name="__codelineno-7-528" href="#__codelineno-7-528"></a>}
</span><span id="__span-7-529"><a id="__codelineno-7-529" name="__codelineno-7-529" href="#__codelineno-7-529"></a>
</span><span id="__span-7-530"><a id="__codelineno-7-530" name="__codelineno-7-530" href="#__codelineno-7-530"></a>eval &quot;\nChurch numeral 1:&quot;
</span><span id="__span-7-531"><a id="__codelineno-7-531" name="__codelineno-7-531" href="#__codelineno-7-531"></a>eval {
</span><span id="__span-7-532"><a id="__codelineno-7-532" name="__codelineno-7-532" href="#__codelineno-7-532"></a>    let one = Term::Lambda(&quot;f&quot;, Term::Pi(&quot;x&quot;, Term::Var(&quot;Any&quot;), Term::Var(&quot;Any&quot;)),
</span><span id="__span-7-533"><a id="__codelineno-7-533" name="__codelineno-7-533" href="#__codelineno-7-533"></a>        Term::Lambda(&quot;x&quot;, Term::Var(&quot;Any&quot;), Term::Apply(Term::Var(&quot;f&quot;), Term::Var(&quot;x&quot;)))
</span><span id="__span-7-534"><a id="__codelineno-7-534" name="__codelineno-7-534" href="#__codelineno-7-534"></a>    )
</span><span id="__span-7-535"><a id="__codelineno-7-535" name="__codelineno-7-535" href="#__codelineno-7-535"></a>    one.pretty ++ &quot;  ≡  &quot; ++ prelude.normalize(one).pretty
</span><span id="__span-7-536"><a id="__codelineno-7-536" name="__codelineno-7-536" href="#__codelineno-7-536"></a>}
</span></code></pre></div>
</div>
<div class="button-container">
    <button class="md-button button-run" onclick="runCodeInEditor('code-mltt', 'result-mltt')">Run Code</button>
</div>
<div class="result-editor" id="result-mltt"></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.action.edit", "navigation.expand"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="../javascripts/editor.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>